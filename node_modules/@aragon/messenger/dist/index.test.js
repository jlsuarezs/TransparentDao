"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_proxyquire=_interopRequireDefault(require("proxyquire")),_rxjs=require("rxjs");const jsonrpcStub={};class MPM{}const Messenger=(0,_proxyquire.default)("./index",{"./jsonrpc":{default:jsonrpcStub},"./providers/MessagePortMessage":{default:MPM}}).default;_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should assign MessagePortMessage as default provider",t=>{// arrange
// act
const instance=new Messenger;// assert
t.true(instance.provider instanceof MPM)}),(0,_ava.default)("should return the messages from provider",t=>{// arrange
const messagesStub=_sinon.default.stub().returns(6),instance=new Messenger({messages:messagesStub}),bus=instance.bus();// assert
t.is(bus,6)}),(0,_ava.default)("should encode and send the response",t=>{// arrange
const payload={id:2,jsonrpc:"2.0"};jsonrpcStub.encodeResponse=_sinon.default.stub().returns(payload);const sendSpy=_sinon.default.spy(),instance=new Messenger({send:sendSpy}),id=instance.sendResponse(200,"success");// assert
t.is(jsonrpcStub.encodeResponse.getCall(0).args[0],200),t.is(jsonrpcStub.encodeResponse.getCall(0).args[1],"success"),t.is(sendSpy.getCall(0).args[0],payload),t.is(id,2)}),(0,_ava.default)("should encode and send the request",t=>{// arrange
const payload={id:"uuuuidv4",jsonrpc:"2.0"};jsonrpcStub.encodeRequest=_sinon.default.stub().returns(payload);const sendSpy=_sinon.default.spy(),instance=new Messenger({send:sendSpy}),id=instance.send("sendEth");// assert
t.is(jsonrpcStub.encodeRequest.getCall(0).args[0],"sendEth"),t.deepEqual(jsonrpcStub.encodeRequest.getCall(0).args[1],[]),t.is(sendSpy.getCall(0).args[0],payload),t.is(id,"uuuuidv4")}),(0,_ava.default)("should filter the incoming messages to responses only",t=>{// arrange
const busMock=new _rxjs.Subject,instance=new Messenger(null);instance.bus=()=>busMock,jsonrpcStub.isValidResponse=_sinon.default.stub().returns(!0),t.plan(2);// act
const messages=instance.responses();messages.subscribe(value=>{t.is(jsonrpcStub.isValidResponse.getCall(0).args[0],"response"),t.is(value,"response")}),busMock.next("response")}),(0,_ava.default)("should filter the incoming messages to requests only",t=>{// arrange
const busMock=new _rxjs.Subject,instance=new Messenger(null);instance.bus=()=>busMock,jsonrpcStub.isValidResponse=_sinon.default.stub().returns(!1),t.plan(2);// act
const messages=instance.requests();messages.subscribe(value=>{t.is(jsonrpcStub.isValidResponse.getCall(0).args[0],"request"),t.is(value,"request")}),busMock.next("request")}),(0,_ava.default)("should send and observe responses",t=>{// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(new _rxjs.Subject),t.plan(4);// act
const messages=instance.sendAndObserveResponses("sendEth");// assert
messages.subscribe(value=>t.is(value.data,"thanks")),t.is(instance.send.getCall(0).args[0],"sendEth"),t.deepEqual(instance.send.getCall(0).args[1],[]),instance.responses().next({data:"thanks",id:41}),instance.responses().next({data:"thanks",id:41})}),(0,_ava.default)("should send and observe only the first response",t=>{// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"sendAndObserveResponses").returns(new _rxjs.Subject),t.plan(3);// act
const messages=instance.sendAndObserveResponse("sendAnt");// assert
messages.subscribe(value=>t.is(value,"first")),t.is(instance.sendAndObserveResponses.getCall(0).args[0],"sendAnt"),t.deepEqual(instance.sendAndObserveResponses.getCall(0).args[1],[]),instance.sendAndObserveResponses().next("first"),instance.sendAndObserveResponses().next("second"),instance.sendAndObserveResponses().next("third")});