"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('../../helpers/web3-fallback'),
    ensureWeb3 = _require.ensureWeb3;

var fs = require('fs');

var tmp = require('tmp-promise');

var path = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var _require3 = require('fs-extra'),
    copy = _require3.copy,
    readJson = _require3.readJson,
    writeJson = _require3.writeJson,
    pathExistsSync = _require3.pathExistsSync;

var extract = require('../../helpers/solidity-extractor');

var APM = require('@aragon/apm');

var semver = require('semver');

var namehash = require('eth-ens-namehash');

var _require4 = require('js-sha3'),
    keccak256 = _require4.keccak256;

var TaskList = require('listr');

var taskInput = require('listr-input');

var _require5 = require('../../util'),
    findProjectRoot = _require5.findProjectRoot,
    getNodePackageManager = _require5.getNodePackageManager;

var ignore = require('ignore');

var execa = require('execa');

var _require6 = require('../../helpers/truffle-runner'),
    compileContracts = _require6.compileContracts;

var web3Utils = require('web3-utils');

var deploy = require('../deploy');

var startIPFS = require('../ipfs');

var getRepoTask = require('../dao_cmds/utils/getRepoTask');

var listrOpts = require('../../helpers/listr-options');

var DEFAULT_GAS_PRICE = require('../../../package.json').aragon.defaultGasPrice;

var MANIFEST_FILE = 'manifest.json';
var ARTIFACT_FILE = 'artifact.json';
var SOLIDITY_FILE = 'code.sol';
exports.command = 'publish <bump> [contract]';
exports.describe = 'Publish a new version of the application';

exports.builder = function (yargs) {
  return deploy.builder(yargs) // inherit deploy options
  .positional('bump', {
    description: 'Type of bump (major, minor or patch) or version number',
    type: 'string'
  }).positional('contract', {
    description: 'The address or name of the contract to publish in this version. If it isn\'t provided, it will default to the current version\'s contract.',
    type: 'string'
  }).option('only-artifacts', {
    description: 'Whether just generate artifacts file without publishing',
    default: false,
    boolean: true
  }).option('provider', {
    description: 'The APM storage provider to publish files to',
    default: 'ipfs',
    choices: ['ipfs']
  }).option('reuse', {
    description: 'Whether to reuse the previous version contract and skip deployment on non-major versions',
    default: false,
    boolean: true
  }).option('files', {
    description: 'Path(s) to directories containing files to publish. Specify multiple times to include multiple files.',
    default: ['.'],
    array: true
  }).option('ignore', {
    description: 'A gitignore pattern of files to ignore. Specify multiple times to add multiple patterns.',
    array: true,
    default: ['node_modules']
  }).option('ipfs-check', {
    description: 'Whether to have publish start IPFS if not started',
    boolean: true,
    default: true
  }).option('publish-dir', {
    description: 'Temporary directory where files will be copied before publishing. Defaults to temp dir.',
    default: null
  }).option('only-content', {
    description: 'Whether to skip contract compilation, deployment and contract artifact generation',
    default: false,
    boolean: true
  }).option('build', {
    description: 'Whether publish should try to build the app before publishing, running the script specified in --build-script',
    default: true,
    boolean: true
  }).option('build-script', {
    description: 'The npm script that will be run when building the app',
    default: 'build'
  }).option('http', {
    description: 'URL for where your app is served e.g. localhost:1234',
    default: null
  }).option('http-served-from', {
    description: 'Directory where your files is being served from e.g. ./dist',
    default: null
  });
};

function generateApplicationArtifact(_x, _x2, _x3, _x4) {
  return _generateApplicationArtifact.apply(this, arguments);
}

function _generateApplicationArtifact() {
  _generateApplicationArtifact = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee12(cwd, outputPath, module, deployArtifacts) {
    var artifact, contractPath, contractInterfacePath, contractInterface;
    return regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            artifact = Object.assign({}, module);
            contractPath = artifact.path;
            contractInterfacePath = path.resolve(cwd, 'build/contracts', path.basename(contractPath, '.sol') + '.json'); // Set `appId`

            artifact.appId = namehash.hash(artifact.appName); // Set ABI

            _context12.next = 6;
            return readJson(contractInterfacePath);

          case 6:
            contractInterface = _context12.sent;
            artifact.abi = contractInterface.abi;

            if (deployArtifacts) {
              artifact.deployment = deployArtifacts;

              if (deployArtifacts.flattenedCode) {
                fs.writeFileSync(path.resolve(outputPath, SOLIDITY_FILE), artifact.deployment.flattenedCode);
                artifact.deployment.flattenedCode = "./".concat(SOLIDITY_FILE);
              }
            } // Analyse contract functions and returns an array
            // > [{ sig: 'transfer(address)', role: 'X_ROLE', notice: 'Transfers..'}]


            _context12.next = 11;
            return extract(path.resolve(cwd, artifact.path));

          case 11:
            artifact.functions = _context12.sent;
            artifact.roles = artifact.roles.map(function (role) {
              return Object.assign(role, {
                bytes: '0x' + keccak256(role.id)
              });
            }); // Save artifact

            _context12.next = 15;
            return writeJson(path.resolve(outputPath, 'artifact.json'), artifact, {
              spaces: '\t'
            });

          case 15:
            return _context12.abrupt("return", artifact);

          case 16:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12, this);
  }));
  return _generateApplicationArtifact.apply(this, arguments);
}

function copyCurrentApplicationArtifacts(_x5, _x6, _x7, _x8) {
  return _copyCurrentApplicationArtifacts.apply(this, arguments);
}
/**
 * Moves the specified files to a temporary directory and returns the path to
 * the temporary directory.
 *
 * @param {Array<string>} files An array of file paths to include
 * @param {string} ignorePatterns An array of glob-like pattern of files to ignore
 * @return {string} The path to the temporary directory
 */


function _copyCurrentApplicationArtifacts() {
  _copyCurrentApplicationArtifacts = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee14(outputPath, apm, repo, newVersion) {
    var copyingFiles, content, uri, copy, updateArtifactVersion;
    return regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            copyingFiles = [ARTIFACT_FILE, SOLIDITY_FILE];
            content = repo.content;
            uri = "".concat(content.provider, ":").concat(content.location);
            _context14.next = 5;
            return Promise.all(copyingFiles.map(
            /*#__PURE__*/
            function () {
              var _ref5 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee13(file) {
                return regeneratorRuntime.wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        _context13.prev = 0;
                        _context13.t0 = path.resolve(outputPath, file);
                        _context13.next = 4;
                        return apm.getFile(uri, file);

                      case 4:
                        _context13.t1 = _context13.sent;
                        _context13.t2 = file;
                        return _context13.abrupt("return", {
                          filePath: _context13.t0,
                          fileContent: _context13.t1,
                          fileName: _context13.t2
                        });

                      case 9:
                        _context13.prev = 9;
                        _context13.t3 = _context13["catch"](0);

                        if (!(file === ARTIFACT_FILE)) {
                          _context13.next = 13;
                          break;
                        }

                        throw _context13.t3;

                      case 13:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13, this, [[0, 9]]);
              }));

              return function (_x26) {
                return _ref5.apply(this, arguments);
              };
            }()));

          case 5:
            copy = _context14.sent;

            updateArtifactVersion = function updateArtifactVersion(file, version) {
              var newContent = JSON.parse(file.fileContent);
              newContent.version = version;
              return _objectSpread({}, file, {
                fileContent: JSON.stringify(newContent, null, 2)
              });
            };

            copy.filter(function (item) {
              return item;
            }).map(function (file) {
              if (file.fileName === ARTIFACT_FILE) {
                return updateArtifactVersion(file, newVersion);
              }

              return file;
            }).forEach(function (_ref6) {
              var fileName = _ref6.fileName,
                  filePath = _ref6.filePath,
                  fileContent = _ref6.fileContent;
              return fs.writeFileSync(filePath, fileContent);
            });

          case 8:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14, this);
  }));
  return _copyCurrentApplicationArtifacts.apply(this, arguments);
}

function prepareFilesForPublishing(_x9) {
  return _prepareFilesForPublishing.apply(this, arguments);
}

function _prepareFilesForPublishing() {
  _prepareFilesForPublishing = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee16(tmpDir) {
    var files,
        ignorePatterns,
        filter,
        projectRoot,
        ipfsignorePath,
        gitignorePath,
        replaceRootRegex,
        filterIgnoredFiles,
        manifestOrigin,
        manifestDst,
        artifactOrigin,
        artifactDst,
        _args16 = arguments;
    return regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            filterIgnoredFiles = function _ref8(src) {
              var relativeSrc = src.replace(replaceRootRegex, '.');
              return !filter.ignores(relativeSrc);
            };

            files = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : [];
            ignorePatterns = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : null;
            // Ignored files filter
            filter = ignore().add(ignorePatterns);
            projectRoot = findProjectRoot();
            ipfsignorePath = path.resolve(projectRoot, '.ipfsignore');

            if (pathExistsSync(ipfsignorePath)) {
              filter.add(fs.readFileSync(ipfsignorePath).toString());
            } else {
              gitignorePath = path.resolve(projectRoot, '.gitignore');

              if (pathExistsSync(gitignorePath)) {
                filter.add(fs.readFileSync(gitignorePath).toString());
              }
            }

            replaceRootRegex = new RegExp("^".concat(projectRoot));
            _context16.next = 10;
            return Promise.all(files.map(
            /*#__PURE__*/
            function () {
              var _ref7 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee15(file) {
                var stats, destination;
                return regeneratorRuntime.wrap(function _callee15$(_context15) {
                  while (1) {
                    switch (_context15.prev = _context15.next) {
                      case 0:
                        _context15.next = 2;
                        return promisify(fs.lstat)(file);

                      case 2:
                        stats = _context15.sent;
                        destination = tmpDir;

                        if (stats.isFile()) {
                          destination = path.resolve(tmpDir, file);
                        }

                        return _context15.abrupt("return", copy(file, destination, {
                          filter: filterIgnoredFiles
                        }));

                      case 6:
                      case "end":
                        return _context15.stop();
                    }
                  }
                }, _callee15, this);
              }));

              return function (_x27) {
                return _ref7.apply(this, arguments);
              };
            }()));

          case 10:
            manifestOrigin = path.resolve(projectRoot, MANIFEST_FILE);
            manifestDst = path.resolve(tmpDir, MANIFEST_FILE);

            if (!(!pathExistsSync(manifestDst) && pathExistsSync(manifestOrigin))) {
              _context16.next = 15;
              break;
            }

            _context16.next = 15;
            return copy(manifestOrigin, manifestDst);

          case 15:
            artifactOrigin = path.resolve(projectRoot, ARTIFACT_FILE);
            artifactDst = path.resolve(tmpDir, ARTIFACT_FILE);

            if (!(!pathExistsSync(artifactDst) && pathExistsSync(artifactOrigin))) {
              _context16.next = 20;
              break;
            }

            _context16.next = 20;
            return copy(artifactOrigin, artifactDst);

          case 20:
            return _context16.abrupt("return", tmpDir);

          case 21:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16, this);
  }));
  return _prepareFilesForPublishing.apply(this, arguments);
}

var POSITIVE_ANSWERS = ['yes', 'y'];
var NEGATIVE_ANSWERS = ['no', 'n', 'abort', 'a'];
var ANSWERS = POSITIVE_ANSWERS.concat(NEGATIVE_ANSWERS);

exports.task = function (_ref) {
  var reporter = _ref.reporter,
      cwd = _ref.cwd,
      web3 = _ref.web3,
      network = _ref.network,
      module = _ref.module,
      apmOptions = _ref.apm,
      silent = _ref.silent,
      debug = _ref.debug,
      bump = _ref.bump,
      contract = _ref.contract,
      onlyArtifacts = _ref.onlyArtifacts,
      alreadyCompiled = _ref.alreadyCompiled,
      reuse = _ref.reuse,
      provider = _ref.provider,
      key = _ref.key,
      files = _ref.files,
      ignore = _ref.ignore,
      ipfsCheck = _ref.ipfsCheck,
      publishDir = _ref.publishDir,
      init = _ref.init,
      getRepo = _ref.getRepo,
      onlyContent = _ref.onlyContent,
      build = _ref.build,
      buildScript = _ref.buildScript,
      http = _ref.http,
      httpServedFrom = _ref.httpServedFrom;

  if (onlyContent) {
    contract = '0x0000000000000000000000000000000000000000';
  }

  apmOptions.ensRegistryAddress = apmOptions['ens-registry'];
  var apm = APM(web3, apmOptions);
  var repo = {
    version: '0.0.0'
  };
  return new TaskList([{
    title: 'Check IPFS',
    task: function task() {
      return startIPFS.task({
        apmOptions: apmOptions
      });
    },
    enabled: function enabled() {
      return !http && ipfsCheck;
    }
  }, {
    title: "Applying version bump (".concat(bump, ")"),
    task: function () {
      var _task = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(ctx) {
        var isValid, getMajor;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                isValid = true;
                _context.prev = 1;
                _context.next = 4;
                return apm.getLatestVersion(module.appName);

              case 4:
                repo = _context.sent;
                ctx.version = semver.valid(bump) ? semver.valid(bump) : semver.inc(repo.version, bump);

                getMajor = function getMajor(version) {
                  return version.split('.')[0];
                };

                ctx.isMajor = getMajor(repo.version) !== getMajor(ctx.version);
                _context.next = 10;
                return apm.isValidBump(module.appName, repo.version, ctx.version);

              case 10:
                isValid = _context.sent;
                _context.next = 23;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](1);

                if (!(_context.t0.message.indexOf('Invalid content URI') === 0)) {
                  _context.next = 17;
                  break;
                }

                return _context.abrupt("return");

              case 17:
                ctx.version = semver.valid(bump) ? semver.valid(bump) : semver.inc(repo.version, bump);

                if (!(apm.validInitialVersions.indexOf(ctx.version) === -1)) {
                  _context.next = 22;
                  break;
                }

                throw new Error('Invalid initial version, it can only be 0.0.1, 0.1.0 or 1.0.0.');

              case 22:
                ctx.isMajor = true; // consider first version as major

              case 23:
                if (isValid) {
                  _context.next = 25;
                  break;
                }

                throw new Error('Version bump is not valid, you have to respect APM bumps policy. Check version upgrade rules in documentation https://hack.aragon.org/docs/aragonos-ref.html#631-version-upgrade-rules');

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 13]]);
      }));

      return function task(_x10) {
        return _task.apply(this, arguments);
      };
    }()
  }, {
    title: 'Compile contracts',
    task: function () {
      var _task2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", compileContracts());

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function task() {
        return _task2.apply(this, arguments);
      };
    }(),
    enabled: function enabled() {
      return !onlyContent && web3Utils.isAddress(contract);
    }
  }, {
    title: 'Deploy contract',
    task: function () {
      var _task3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(ctx) {
        var deployTaskParams;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                deployTaskParams = {
                  contract: contract,
                  init: init,
                  reporter: reporter,
                  network: network,
                  cwd: cwd,
                  web3: web3,
                  apmOptions: apmOptions
                };
                return _context3.abrupt("return", deploy.task(deployTaskParams));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function task(_x11) {
        return _task3.apply(this, arguments);
      };
    }(),
    enabled: function enabled(ctx) {
      return !onlyContent && (contract && !web3Utils.isAddress(contract) || !contract && ctx.isMajor && !reuse);
    }
  }, {
    title: 'Determine contract address for version',
    task: function () {
      var _task5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(ctx, _task4) {
        var _ref2, contractAddress;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (web3Utils.isAddress(contract)) {
                  ctx.contract = contract;
                } // Check if we can fall back to a previous contract address


                if (!(!ctx.contract && apm.validInitialVersions.indexOf(ctx.version) === -1)) {
                  _context4.next = 15;
                  break;
                }

                _task4.output = 'No contract address provided, using previous one';
                _context4.prev = 3;
                _context4.next = 6;
                return apm.getLatestVersion(module.appName);

              case 6:
                _ref2 = _context4.sent;
                contractAddress = _ref2.contractAddress;
                ctx.contract = contractAddress;
                return _context4.abrupt("return", "Using ".concat(ctx.contract));

              case 12:
                _context4.prev = 12;
                _context4.t0 = _context4["catch"](3);
                throw new Error('Could not determine previous contract');

              case 15:
                if (ctx.contract) {
                  _context4.next = 17;
                  break;
                }

                throw new Error('No contract address supplied for initial version');

              case 17:
                return _context4.abrupt("return", "Using ".concat(contract));

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 12]]);
      }));

      return function task(_x12, _x13) {
        return _task5.apply(this, arguments);
      };
    }(),
    enabled: function enabled() {
      return !onlyArtifacts;
    }
  }, {
    title: 'Building frontend',
    enabled: function enabled() {
      return build && !http;
    },
    task: function () {
      var _task7 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(ctx, _task6) {
        var packageJson, scripts, bin, buildTask;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (fs.existsSync('package.json')) {
                  _context5.next = 3;
                  break;
                }

                _task6.skip('No package.json found');

                return _context5.abrupt("return");

              case 3:
                _context5.next = 5;
                return readJson('package.json');

              case 5:
                packageJson = _context5.sent;
                scripts = packageJson.scripts || {};

                if (scripts[buildScript]) {
                  _context5.next = 10;
                  break;
                }

                _task6.skip('Build script not defined in package.json');

                return _context5.abrupt("return");

              case 10:
                bin = getNodePackageManager();
                buildTask = execa(bin, ['run', buildScript]);
                buildTask.stdout.on('data', function (log) {
                  if (!log) return;
                  _task6.output = "npm run ".concat(buildScript, ": ").concat(log);
                });
                return _context5.abrupt("return", buildTask.catch(function (err) {
                  throw new Error("".concat(err.message, "\n").concat(err.stderr, "\n\nFailed to build. See above output."));
                }));

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function task(_x14, _x15) {
        return _task7.apply(this, arguments);
      };
    }()
  }, {
    title: 'Prepare files for publishing',
    task: function () {
      var _task9 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(ctx, _task8) {
        var _ref3, tmpDir;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (publishDir) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 3;
                return tmp.dir();

              case 3:
                _ref3 = _context6.sent;
                tmpDir = _ref3.path;
                publishDir = tmpDir;

              case 6:
                _context6.next = 8;
                return prepareFilesForPublishing(publishDir, files, ignore);

              case 8:
                ctx.pathToPublish = publishDir;
                return _context6.abrupt("return", "Files copied to temporary directory: ".concat(ctx.pathToPublish));

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function task(_x16, _x17) {
        return _task9.apply(this, arguments);
      };
    }(),
    enabled: function enabled() {
      return !http;
    }
  }, {
    title: 'Check for --http-served-from argument and copy manifest.json to destination',
    task: function () {
      var _task11 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(ctx, _task10) {
        var projectRoot, manifestOrigin, manifestDst, manifest;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (httpServedFrom) {
                  _context7.next = 2;
                  break;
                }

                throw new Error('You need to provide --http-served-from argument');

              case 2:
                projectRoot = findProjectRoot();
                manifestOrigin = path.resolve(projectRoot, MANIFEST_FILE);
                manifestDst = path.resolve(httpServedFrom, MANIFEST_FILE);

                if (!(!pathExistsSync(manifestDst) && pathExistsSync(manifestOrigin))) {
                  _context7.next = 13;
                  break;
                }

                _context7.next = 8;
                return readJson(manifestOrigin);

              case 8:
                manifest = _context7.sent;
                manifest.start_url = path.basename(manifest.start_url);
                manifest.script = path.basename(manifest.script);
                _context7.next = 13;
                return writeJson(manifestDst, manifest);

              case 13:
                ctx.pathToPublish = httpServedFrom;

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function task(_x18, _x19) {
        return _task11.apply(this, arguments);
      };
    }(),
    enabled: function enabled() {
      return http;
    }
  }, {
    title: 'Generate application artifact',
    skip: function skip() {
      return onlyContent && !module.path;
    },
    task: function () {
      var _task13 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(ctx, _task12) {
        var dir;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                dir = onlyArtifacts ? cwd : ctx.pathToPublish;

                if (!pathExistsSync("".concat(dir, "/").concat(ARTIFACT_FILE))) {
                  _context9.next = 3;
                  break;
                }

                return _context9.abrupt("return", _task12.skip('Using existent artifact'));

              case 3:
                if (!onlyContent) {
                  _context9.next = 14;
                  break;
                }

                _context9.prev = 4;
                _task12.output = 'Fetching artifacts from previous version';
                _context9.next = 8;
                return copyCurrentApplicationArtifacts(dir, apm, ctx.repo, ctx.version);

              case 8:
                return _context9.abrupt("return", _task12.skip("Using artifacts from v".concat(ctx.repo.version)));

              case 11:
                _context9.prev = 11;
                _context9.t0 = _context9["catch"](4);
                return _context9.abrupt("return", taskInput('Couldn\'t fetch existing artifact, generate now? [y]es/[a]bort', {
                  validate: function validate(value) {
                    return ANSWERS.indexOf(value) > -1;
                  },
                  done: function () {
                    var _done = _asyncToGenerator(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee8(answer) {
                      return regeneratorRuntime.wrap(function _callee8$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              if (!(POSITIVE_ANSWERS.indexOf(answer) > -1)) {
                                _context8.next = 4;
                                break;
                              }

                              _context8.next = 3;
                              return generateApplicationArtifact(cwd, dir, module, ctx.deployArtifacts);

                            case 3:
                              return _context8.abrupt("return", "Saved artifact in ".concat(dir, "/artifact.json"));

                            case 4:
                              throw new Error('Aborting publication...');

                            case 5:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, _callee8, this);
                    }));

                    return function done(_x22) {
                      return _done.apply(this, arguments);
                    };
                  }()
                }));

              case 14:
                _context9.next = 16;
                return generateApplicationArtifact(cwd, dir, module, ctx.deployArtifacts);

              case 16:
                return _context9.abrupt("return", "Saved artifact in ".concat(dir, "/artifact.json"));

              case 17:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[4, 11]]);
      }));

      return function task(_x20, _x21) {
        return _task13.apply(this, arguments);
      };
    }()
  }, {
    title: "Publish ".concat(module.appName),
    task: function () {
      var _task15 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(ctx, _task14) {
        var accounts, from, transaction;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                ctx.contractInstance = null; // clean up deploy sub-command artifacts

                _task14.output = 'Generating transaction and waiting for confirmation';
                _context10.next = 4;
                return web3.eth.getAccounts();

              case 4:
                accounts = _context10.sent;
                from = accounts[0];
                _context10.prev = 6;
                _context10.next = 9;
                return apm.publishVersion(from, module.appName, ctx.version, http ? 'http' : provider, http || ctx.pathToPublish, ctx.contract, from);

              case 9:
                transaction = _context10.sent;
                transaction.from = from;
                transaction.gasPrice = network.gasPrice || DEFAULT_GAS_PRICE;
                _context10.next = 14;
                return web3.eth.sendTransaction(transaction);

              case 14:
                ctx.receipt = _context10.sent;
                _context10.next = 20;
                break;

              case 17:
                _context10.prev = 17;
                _context10.t0 = _context10["catch"](6);
                throw _context10.t0;

              case 20:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[6, 17]]);
      }));

      return function task(_x23, _x24) {
        return _task15.apply(this, arguments);
      };
    }(),
    enabled: function enabled() {
      return !onlyArtifacts;
    }
  }, {
    title: 'Fetch published repo',
    task: getRepoTask.task({
      artifactRequired: false,
      apmRepo: module.appName,
      apm: apm
    })
  }], listrOpts(silent, debug));
};

exports.handler =
/*#__PURE__*/
function () {
  var _ref4 = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee11(args) {
    var reporter, network, module, onlyContent, web3;
    return regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            reporter = args.reporter, network = args.network, module = args.module, onlyContent = args.onlyContent;
            _context11.next = 3;
            return ensureWeb3(network);

          case 3:
            web3 = _context11.sent;
            return _context11.abrupt("return", exports.task(_objectSpread({}, args, {
              web3: web3
            })).run({
              web3: web3
            }).then(function (ctx) {
              var appName = module.appName;
              var _ctx$receipt = ctx.receipt,
                  transactionHash = _ctx$receipt.transactionHash,
                  status = _ctx$receipt.status;
              var _ctx$repo = ctx.repo,
                  version = _ctx$repo.version,
                  content = _ctx$repo.content,
                  contractAddress = _ctx$repo.contractAddress;
              console.log();

              if (!status) {
                reporter.error("Publish transaction reverted:");
              } else {
                reporter.success("Successfully published ".concat(appName, " v").concat(version, ": "));

                if (!onlyContent) {
                  reporter.info("Contract address: ".concat(contractAddress));
                }

                reporter.info("Content (".concat(content.provider, "): ").concat(content.location));
              }

              reporter.info("Transaction hash: ".concat(transactionHash));
              reporter.debug("Published directory: ".concat(ctx.pathToPublish));
              process.exit(status ? 0 : 1);
            }).catch(function () {
              process.exit(1);
            }));

          case 5:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, this);
  }));

  return function (_x25) {
    return _ref4.apply(this, arguments);
  };
}();