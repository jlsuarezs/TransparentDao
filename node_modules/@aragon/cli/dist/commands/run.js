"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var TaskList = require('listr');

var Web3 = require('web3');

var chalk = require('chalk');

var path = require('path');

var publish = require('./apm_cmds/publish');

var devchain = require('./devchain');

var deploy = require('./deploy');

var newDAO = require('./dao_cmds/new');

var startIPFS = require('./ipfs');

var encodeInitPayload = require('./dao_cmds/utils/encodeInitPayload');

var _require = require('util'),
    promisify = _require.promisify;

var clone = promisify(require('git-clone'));

var os = require('os');

var fs = require('fs-extra');

var opn = require('opn');

var execa = require('execa');

var pkg = require('../../package.json');

var listrOpts = require('../helpers/listr-options');

var _require2 = require('../util'),
    findProjectRoot = _require2.findProjectRoot,
    isPortTaken = _require2.isPortTaken,
    installDeps = _require2.installDeps,
    getNodePackageManager = _require2.getNodePackageManager;

var url = require('url');

var DEFAULT_CLIENT_VERSION = pkg.aragon.clientVersion;
var DEFAULT_CLIENT_PORT = pkg.aragon.clientPort;
exports.command = 'run';
exports.describe = 'Run the current app locally';

exports.builder = function (yargs) {
  return yargs.option('client', {
    description: 'Just run the smart contracts, without the Aragon client',
    default: true,
    boolean: true
  }).option('files', {
    description: 'Path(s) to directories containing files to publish. Specify multiple times to include multiple files.',
    default: ['.'],
    array: true
  }).option('port', {
    description: 'Port to start devchain at',
    default: '8545'
  }).option('accounts', {
    default: 2,
    description: 'Number of accounts to print'
  }).option('reset', {
    default: false,
    boolean: true,
    description: 'Reset devchain to snapshot'
  }).option('kit', {
    default: newDAO.BARE_KIT,
    description: 'Kit contract name'
  }).option('kit-init', {
    description: 'Arguments to be passed to the kit constructor',
    array: true,
    default: []
  }).option('kit-deploy-event', {
    description: 'Arguments to be passed to the kit constructor',
    default: newDAO.BARE_KIT_DEPLOY_EVENT
  }).option('build-script', {
    description: 'The npm script that will be run when building the app',
    default: 'build'
  }).option('http', {
    description: 'URL for where your app is served from e.g. localhost:1234',
    default: null
  }).option('http-served-from', {
    description: 'Directory where your files is being served from e.g. ./dist',
    default: null
  }).option('app-init', {
    description: 'Name of the function that will be called to initialize an app',
    default: 'initialize'
  }).option('app-init-args', {
    description: 'Arguments for calling the app init function',
    array: true,
    default: []
  }).option('client-version', {
    description: 'Version of Aragon client used to run your sandboxed app',
    default: DEFAULT_CLIENT_VERSION
  }).option('client-port', {
    description: 'Port being used by Aragon client',
    default: DEFAULT_CLIENT_PORT
  }).option('client-path', {
    description: 'A path pointing to an existing Aragon client installation',
    default: null
  });
};

exports.handler = function (_ref) {
  var reporter = _ref.reporter,
      cwd = _ref.cwd,
      apmOptions = _ref.apm,
      silent = _ref.silent,
      debug = _ref.debug,
      network = _ref.network,
      module = _ref.module,
      client = _ref.client,
      files = _ref.files,
      port = _ref.port,
      accounts = _ref.accounts,
      reset = _ref.reset,
      kit = _ref.kit,
      kitInit = _ref.kitInit,
      kitDeployEvent = _ref.kitDeployEvent,
      buildScript = _ref.buildScript,
      http = _ref.http,
      httpServedFrom = _ref.httpServedFrom,
      appInit = _ref.appInit,
      appInitArgs = _ref.appInitArgs,
      clientVersion = _ref.clientVersion,
      clientPort = _ref.clientPort,
      clientPath = _ref.clientPath;
  apmOptions.ensRegistryAddress = apmOptions['ens-registry'];
  clientPort = clientPort || DEFAULT_CLIENT_PORT;
  var showAccounts = accounts;
  var tasks = new TaskList([{
    title: 'Start a local Ethereum network',
    skip: function () {
      var _skip = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(ctx) {
        var hostURL;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                hostURL = new url.URL(network.provider.connection._url);
                _context.next = 3;
                return isPortTaken(hostURL.port);

              case 3:
                if (_context.sent) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", false);

              case 7:
                ctx.web3 = new Web3(network.provider);
                _context.next = 10;
                return ctx.web3.eth.getAccounts();

              case 10:
                ctx.accounts = _context.sent;
                return _context.abrupt("return", 'Connected to the provided Ethereum network');

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function skip(_x) {
        return _skip.apply(this, arguments);
      }

      return skip;
    }(),
    task: function () {
      var _task2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(ctx, _task) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", devchain.task({
                  port: port,
                  reset: reset,
                  showAccounts: showAccounts
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function task(_x2, _x3) {
        return _task2.apply(this, arguments);
      }

      return task;
    }()
  }, {
    title: 'Check IPFS',
    task: function task() {
      return startIPFS.task({
        apmOptions: apmOptions
      });
    },
    enabled: function enabled() {
      return !http || kit;
    }
  }, {
    title: 'Publish app to APM',
    task: function () {
      var _task3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(ctx) {
        var publishParams;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                publishParams = {
                  alreadyCompiled: true,
                  provider: 'ipfs',
                  files: files,
                  ignore: ['node_modules'],
                  reporter: reporter,
                  cwd: cwd,
                  network: network,
                  module: module,
                  buildScript: buildScript,
                  build: true,
                  contract: deploy.arappContract(),
                  web3: ctx.web3,
                  apm: apmOptions,
                  bump: 'major',
                  getRepo: true,
                  http: http,
                  httpServedFrom: httpServedFrom
                };
                return _context3.abrupt("return", publish.task(publishParams));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function task(_x4) {
        return _task3.apply(this, arguments);
      }

      return task;
    }()
  }, {
    title: 'Deploy Kit',
    enabled: function enabled() {
      return kit !== newDAO.BARE_KIT;
    },
    task: function task(ctx) {
      var deployParams = {
        contract: kit,
        init: kitInit,
        reporter: reporter,
        network: network,
        cwd: cwd,
        web3: ctx.web3,
        apmOptions: apmOptions
      };
      return deploy.task(deployParams);
    }
  }, {
    title: 'Create DAO',
    task: function task(ctx) {
      var roles = ctx.repo.roles.map(function (role) {
        return role.bytes;
      });
      var fnArgs;

      if (ctx.contractInstance) {
        // If no kit was deployed, use default params
        fnArgs = [];
      } else {
        // TODO: Report warning when app wasn't initialized
        var initPayload = encodeInitPayload(ctx.web3, ctx.repo.abi, appInit, appInitArgs);

        if (initPayload === '0x') {
          ctx.notInitialized = true;
        }

        fnArgs = [ctx.repo.appId, roles, ctx.accounts[0], initPayload];
      }

      var newDAOParams = {
        kit: kit,
        kitVersion: 'latest',
        kitInstance: ctx.contractInstance,
        fn: 'newInstance',
        fnArgs: fnArgs,
        deployEvent: kitDeployEvent,
        web3: ctx.web3,
        reporter: reporter,
        apmOptions: apmOptions
      };
      return newDAO.task(newDAOParams);
    }
  }, {
    title: 'Open DAO',
    task: function task(ctx, _task4) {
      return new TaskList([{
        title: 'Download client',
        skip: function skip() {
          return !!clientPath;
        },
        task: function task(ctx, _task5) {
          clientVersion = clientVersion || DEFAULT_CLIENT_VERSION;
          var CLIENT_PATH = "".concat(os.homedir(), "/.aragon/wrapper-").concat(clientVersion);
          ctx.wrapperPath = CLIENT_PATH; // Make sure we haven't already downloaded the wrapper

          if (fs.existsSync(path.resolve(CLIENT_PATH))) {
            _task5.skip('Client already downloaded');

            ctx.wrapperAvailable = true;
            return;
          } // Ensure folder exists


          fs.ensureDirSync(CLIENT_PATH); // Clone wrapper

          return clone('https://github.com/aragon/aragon', CLIENT_PATH, {
            checkout: clientVersion
          });
        }
      }, {
        title: 'Install client dependencies',
        task: function () {
          var _task7 = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee4(ctx, _task6) {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", installDeps(ctx.wrapperPath, _task6));

                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function task(_x5, _x6) {
            return _task7.apply(this, arguments);
          }

          return task;
        }(),
        enabled: function enabled(ctx) {
          return !ctx.wrapperAvailable && !clientPath;
        }
      }, {
        title: 'Start Aragon client',
        task: function () {
          var _task9 = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee5(ctx, _task8) {
            var bin, startArguments;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return isPortTaken(clientPort);

                  case 2:
                    if (!_context5.sent) {
                      _context5.next = 5;
                      break;
                    }

                    ctx.portOpen = true;
                    return _context5.abrupt("return");

                  case 5:
                    bin = getNodePackageManager();
                    startArguments = {
                      cwd: clientPath || ctx.wrapperPath,
                      env: {
                        REACT_APP_ENS_REGISTRY_ADDRESS: ctx.ens,
                        REACT_APP_PORT: clientPort
                      }
                    };
                    execa(bin, ['run', 'start:local'], startArguments).catch(function (err) {
                      throw new Error(err);
                    });

                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function task(_x7, _x8) {
            return _task9.apply(this, arguments);
          }

          return task;
        }()
      }, {
        title: 'Open client',
        task: function task(ctx, _task10) {
          // Check until the wrapper is served
          var checkWrapperReady = function checkWrapperReady() {
            setTimeout(
            /*#__PURE__*/
            _asyncToGenerator(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee6() {
              var portTaken;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.next = 2;
                      return isPortTaken(clientPort);

                    case 2:
                      portTaken = _context6.sent;

                      if (portTaken) {
                        opn("http://localhost:".concat(clientPort, "/#/").concat(ctx.daoAddress));
                      } else {
                        checkWrapperReady();
                      }

                    case 4:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            })), 250);
          };

          checkWrapperReady();
        }
      }]);
    },
    enabled: function enabled() {
      return client === true;
    }
  }], listrOpts(silent, debug));
  var manifestPath = path.resolve(findProjectRoot(), 'manifest.json');
  var manifest;

  if (fs.existsSync(manifestPath)) {
    manifest = fs.readJsonSync(manifestPath);
  }

  return tasks.run({
    ens: apmOptions['ens-registry']
  }).then(
  /*#__PURE__*/
  function () {
    var _ref3 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee7(ctx) {
      var registry;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (ctx.portOpen) {
                reporter.warning("Server already listening at port ".concat(clientPort, ", skipped starting Aragon"));
              }

              if (ctx.notInitialized) {
                reporter.warning('App could not be initialized, check the --app-init flag. Functions protected behind the ACL will not work until the app is initialized');
              }

              reporter.info("You are now ready to open your app in Aragon.");

              if (ctx.privateKeys) {
                devchain.printAccounts(reporter, ctx.privateKeys);
              }

              if (ctx.mnemonic) {
                devchain.printMnemonic(reporter, ctx.mnemonic);
              }

              devchain.printResetNotice(reporter, reset);
              registry = module.appName.split('.').slice(1).join('.');
              console.log();
              reporter.info("This is the configuration for your development deployment:\n    ".concat(chalk.bold('Ethereum Node'), ": ").concat(network.provider.connection._url, "\n    ").concat(chalk.bold('ENS registry'), ": ").concat(ctx.ens, "\n    ").concat(chalk.bold("APM registry"), ": ").concat(registry, "\n    ").concat(chalk.bold('DAO address'), ": ").concat(ctx.daoAddress, "\n\n    ").concat(client !== false ? "Opening http://localhost:".concat(clientPort, "/#/").concat(ctx.daoAddress, " to view your DAO") : "Use \"aragon dao <command> ".concat(ctx.daoAddress, "\" to interact with your DAO")));

              if (!manifest) {
                reporter.warning('No front-end detected (no manifest.json)');
              } else if (!manifest.start_url) {
                reporter.warning('No front-end detected (no start_url defined)');
              }

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    return function (_x9) {
      return _ref3.apply(this, arguments);
    };
  }());
};