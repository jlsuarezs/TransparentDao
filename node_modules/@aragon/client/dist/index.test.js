"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_proxyquire=_interopRequireDefault(require("proxyquire")),_Rx=require("rxjs/Rx");const Index=_proxyquire.default.noCallThru().load("./index",{"@aragon/messenger":{}});_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should send intent when the method does not exist in target",t=>{t.plan(3);// arrange
const observable=_Rx.Observable.of({id:"uuid1",result:10}),instanceStub={rpc:{sendAndObserveResponse:_sinon.default.stub().returns(observable)}// act
},result=Index.AppProxyHandler.get(instanceStub,"add")(5);// assert
result.subscribe(value=>{t.is(value,10)}),t.is(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[0],"intent"),t.deepEqual(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[1],["add",5])}),(0,_ava.default)("should return the network details as an observable",t=>{t.plan(3);// arrange
const networkDetails={id:4,type:"rinkeby"},networkFn=Index.AppProxy.prototype.network,observable=_Rx.Observable.of({jsonrpc:"2.0",id:"uuid1",result:networkDetails}),instanceStub={rpc:{sendAndObserveResponses:_sinon.default.stub().returns(observable)}// act
},result=networkFn.call(instanceStub);// assert
// the call to sendAndObserveResponse is made before we subscribe
t.truthy(instanceStub.rpc.sendAndObserveResponses.getCall(0)),result.subscribe(value=>{t.deepEqual(value,networkDetails)}),t.is(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[0],"network")}),(0,_ava.default)("should return the accounts as an observable",t=>{t.plan(3);// arrange
const accountsFn=Index.AppProxy.prototype.accounts,observable=_Rx.Observable.of({jsonrpc:"2.0",id:"uuid1",result:["accountX","accountY","accountZ"]}),instanceStub={rpc:{sendAndObserveResponses:_sinon.default.stub().returns(observable)}// act
},result=accountsFn.call(instanceStub);// assert
// the call to sendAndObserveResponse is made before we subscribe
t.truthy(instanceStub.rpc.sendAndObserveResponses.getCall(0)),result.subscribe(value=>{t.deepEqual(value,["accountX","accountY","accountZ"])}),t.is(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[0],"accounts")}),(0,_ava.default)("should send an identify request",t=>{t.plan(2);// arrange
const identifyFn=Index.AppProxy.prototype.identify,instanceStub={rpc:{send:_sinon.default.stub()}// act
};// assert
identifyFn.call(instanceStub,"ANT"),t.is(instanceStub.rpc.send.getCall(0).args[0],"identify"),t.deepEqual(instanceStub.rpc.send.getCall(0).args[1],["ANT"])}),(0,_ava.default)("should return the events observable",t=>{t.plan(3);// arrange
const eventsFn=Index.AppProxy.prototype.events,observable=_Rx.Observable.of({id:"uuid1",result:["eventA","eventB"]}),instanceStub={rpc:{sendAndObserveResponses:_sinon.default.stub().returns(observable)}// act
},result=eventsFn.call(instanceStub);// assert
// the call to sendAndObserveResponse should be defered until we subscribe
t.falsy(instanceStub.rpc.sendAndObserveResponses.getCall(0)),result.subscribe(value=>{t.deepEqual(value,["eventA","eventB"])}),t.is(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[0],"events")}),(0,_ava.default)("should return an handle for an external contract events",t=>{t.plan(7);// arrange
const externalFn=Index.AppProxy.prototype.external,observableA=_Rx.Observable.of({id:"uuid1",result:{name:"eventA",value:3e3}}),observableB=_Rx.Observable.of({id:"uuid4",result:"bob was granted permission for the counter app"}),jsonInterfaceStub=[{type:"event",name:"SetPermission"},{type:"function",name:"grantPermission",constant:!0}],instanceStub={rpc:{sendAndObserveResponses:_sinon.default.stub().returns(observableA),sendAndObserveResponse:_sinon.default.stub().returns(observableB)}// act
},result=externalFn.call(instanceStub,"0xextContract",jsonInterfaceStub);// assert
// the call to sendAndObserveResponse should be defered until we subscribe
// events from block 2
t.falsy(instanceStub.rpc.sendAndObserveResponses.getCall(0)),result.events(2).subscribe(value=>{t.deepEqual(value,{name:"eventA",value:3e3}),t.is(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[0],"external_events"),t.deepEqual(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[1],["0xextContract",[jsonInterfaceStub[0]],2])}),result.grantPermission("0xbob","0xcounter").subscribe(value=>{t.is(value,"bob was granted permission for the counter app"),t.is(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[0],"external_call"),t.deepEqual(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[1],["0xextContract",jsonInterfaceStub[1],"0xbob","0xcounter"])})}),(0,_ava.default)("should return the state from cache",t=>{t.plan(3);// arrange
const stateFn=Index.AppProxy.prototype.state,observable=_Rx.Observable.of({id:"uuid1",result:{counter:5}}),instanceStub={rpc:{sendAndObserveResponses:_sinon.default.stub().returns(observable)}// act
},result=stateFn.call(instanceStub);// assert
t.is(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[0],"cache"),t.deepEqual(instanceStub.rpc.sendAndObserveResponses.getCall(0).args[1],["get","state"]),result.subscribe(value=>{t.deepEqual(value,{counter:5})})}),(0,_ava.default)("should create a store/state reducer",async t=>{t.plan(2);// arrange
const storeFn=Index.AppProxy.prototype.store,observableA=_Rx.Observable.from([{actionHistory:[{event:"Add",payload:5}],counter:5},{// this will be ignored, but recalculated correctly because we still have the event
actionHistory:[{event:"Add",payload:5},{event:"Add",payload:2}],counter:7}]),observableB=_Rx.Observable.from([{event:"Add",payload:2},{event:"Add",payload:10}]),instanceStub={state:()=>observableA,events:()=>observableB,cache:_sinon.default.stub().returnsArg(1)// should return 2nd argument
},result=storeFn.call(instanceStub,(state,action)=>{switch(null===state&&(state={actionHistory:[],counter:0}),action.event){case"Add":return state.actionHistory.push(action),state.counter+=action.payload,state;case"Subtract":return state.actionHistory.push(action),state.counter-=action.payload,state;}return state});// assert
result.subscribe(value=>{7===value.counter&&t.deepEqual(value.actionHistory,[{event:"Add",payload:5},{event:"Add",payload:2}]),17===value.counter&&t.deepEqual(value.actionHistory,[{event:"Add",payload:5},{event:"Add",payload:2},{event:"Add",payload:10}])})}),(0,_ava.default)("should perform a call to the contract and observe the response",t=>{t.plan(3);// arrange
const callFn=Index.AppProxy.prototype.call,observable=_Rx.Observable.of({id:"uuid1",result:"success"}),instanceStub={rpc:{sendAndObserveResponse:_sinon.default.stub().returns(observable)}// act
},result=callFn.call(instanceStub,"transferEth",10);// assert
t.is(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[0],"call"),t.deepEqual(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[1],["transferEth",10]),result.subscribe(value=>{t.deepEqual(value,"success")})}),(0,_ava.default)("should listen for app contexts sent from the wrapper and return the first param",t=>{t.plan(2);// arrange
const contextFn=Index.AppProxy.prototype.context,observable=_Rx.Observable.from([{id:"uuid0",// this will get filtered out
params:["x","y"]},{id:"uuid1",method:"context",params:["first","second"]},{id:"uuid4",method:"context",params:[1,2]}]),instanceStub={rpc:{requests:_sinon.default.stub().returns(observable)}// act
},result=contextFn.call(instanceStub);// assert
result.subscribe(value=>{t.true("first"===value||1===value)})}),(0,_ava.default)("should send a describeScript request and observe the response",t=>{t.plan(3);// arrange
const describeScriptFn=Index.AppProxy.prototype.describeScript,observable=_Rx.Observable.of({id:"uuid1",result:"script executed"}),instanceStub={rpc:{sendAndObserveResponse:_sinon.default.stub().returns(observable)}// act
},result=describeScriptFn.call(instanceStub,"goto fail");// assert
t.is(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[0],"describe_script"),t.deepEqual(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[1],["goto fail"]),result.subscribe(value=>{t.deepEqual(value,"script executed")})}),(0,_ava.default)("should send a web3Eth function request and observe the response",t=>{t.plan(3);// arrange
const web3EthFn=Index.AppProxy.prototype.web3Eth,observable=_Rx.Observable.of({id:"uuid1",result:["accountA","accountB"]}),instanceStub={rpc:{sendAndObserveResponse:_sinon.default.stub().returns(observable)}// act
},result=web3EthFn.call(instanceStub,"getAccounts",5);// assert
t.is(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[0],"web3_eth"),t.deepEqual(instanceStub.rpc.sendAndObserveResponse.getCall(0).args[1],["getAccounts",5]),result.subscribe(value=>{t.deepEqual(value,["accountA","accountB"])})});
//# sourceMappingURL=index.test.js.map