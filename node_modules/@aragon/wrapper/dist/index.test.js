"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_proxyquire=_interopRequireDefault(require("proxyquire")),_Rx=require("rxjs/Rx");const messengerConstructorStub=_sinon.default.stub(),utilsStub={makeAddressMapProxy:_sinon.default.fake.returns({}),makeProxy:_sinon.default.stub(),addressesEqual:Object.is},Aragon=_proxyquire.default.noCallThru().load("./index",{"@aragon/messenger":messengerConstructorStub,"./utils":utilsStub}).default;_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should get the accounts",async t=>{// arrange
const instance=new Aragon;instance.web3={eth:{getAccounts:_sinon.default.stub().returns(["0x01","0x02"])}// act
},await instance.initAccounts(null);const accounts=await instance.getAccounts();// assert
t.deepEqual(accounts,["0x01","0x02"])}),(0,_ava.default)("should init the ACL correctly",async t=>{t.plan(1);// arrange
const setPermissionEvents=_Rx.Observable.create(observer=>{observer.next({event:"SetPermission",returnValues:{app:"counter",role:"add",allowed:!0,entity:"0x1"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!0,entity:"0x1"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"add",allowed:!0,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!0,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!1,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!1,entity:"0x2"}})}),changePermissionManagerEvents=_Rx.Observable.create(observer=>{observer.next({event:"ChangePermissionManager",returnValues:{app:"counter",role:"subtract",manager:"manager"}})}),instance=new Aragon;instance.kernelProxy={call:_sinon.default.stub()};const aclProxyStub={events:_sinon.default.stub()};// assert, tell ava to wait for the permissions observable to debounce
return aclProxyStub.events.withArgs("SetPermission").returns(setPermissionEvents),aclProxyStub.events.withArgs("ChangePermissionManager").returns(changePermissionManagerEvents),utilsStub.makeProxy.returns(aclProxyStub),await instance.initAcl(),new Promise(resolve=>{instance.permissions.subscribe(value=>{t.deepEqual(value,{counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"manager"}}}),setTimeout(resolve,2e3)})})}),(0,_ava.default)("should init the apps correctly",async t=>{t.plan(2);// arrange
const instance=new Aragon;// act
// assert
// hack: wait 200ms for the subscribe callback above to be called,
// otherwise it will emit with the identifier set below
// act
// assert
instance.permissions=_Rx.Observable.create(observer=>{observer.next({"0x123":"some permissions","0x456":"some permissions","0x789":"some permissions"})}),instance.kernelProxy={address:"0x123"},instance.getAppProxyValues=appAddress=>({appId:"0x456"===appAddress?"counterApp":"votingApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:appAddress}),instance.apm.getLatestVersionForContract=appId=>Promise.resolve({abi:`abi for ${appId}`}),await instance.initApps(),instance.appsWithoutIdentifiers.subscribe(value=>{t.deepEqual(value,[{abi:"abi for counterApp",appId:"counterApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x456"},{abi:"abi for votingApp",appId:"votingApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x789"}])}),await new Promise(resolve=>setTimeout(resolve,200)),await instance.setAppIdentifier("0x456","CNT"),instance.apps.subscribe(value=>{t.deepEqual(value,[{abi:"abi for counterApp",appId:"counterApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x456",identifier:"CNT"},{abi:"abi for votingApp",appId:"votingApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x789"}])})}),(0,_ava.default)("should init the forwarders correctly",async t=>{t.plan(1);// arrange
const instance=new Aragon;// act
// assert
instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"counterApp",isForwarder:!0},{appId:"votingApp",isForwarder:!1}])}),await instance.initForwarders(),instance.forwarders.subscribe(value=>{t.deepEqual(value,[{appId:"counterApp",isForwarder:!0}])})}),(0,_ava.default)("should init the notifications correctly",async t=>{t.plan(7);// arrange
const instance=new Aragon;// act
// assert
instance.cache.get=_sinon.default.stub().withArgs("notifications").returns([{read:!0,title:"send"},{read:!1,title:"receive"}]),instance.cache.set=_sinon.default.stub(),await instance.initNotifications(),instance.notifications.subscribe(value=>{// only the receive notification should get an acknowledge fn attached
t.is(value[0].read,!0),t.is(value[0].title,"send"),t.is(value[1].read,!1),t.is(value[1].title,"receive"),t.is("acknowledge"in value[1],!0)}),t.is(instance.cache.set.getCall(0).args[0],"notifications"),t.is(instance.cache.set.getCall(0).args[1].length,2)}),(0,_ava.default)("should send notifications correctly",async t=>{t.plan(12);// arrange
const instance=new Aragon;// act
// assert
await instance.initNotifications(),await instance.sendNotification("counterApp","add"),await instance.sendNotification("counterApp","subtract",null,null,new Date(2)),instance.notifications.subscribe(value=>{// uuidv4
t.is(value[0].app,"counterApp"),t.is(value[0].title,"subtract"),t.is(value[0].read,!1),t.is(value[0].body,null),t.is(value[0].context,null),t.is(value[0].id.length,36),t.is(value[1].app,"counterApp"),t.is(value[1].title,"add"),t.is(value[1].read,!1),t.is(value[1].body,void 0),t.deepEqual(value[1].context,{}),t.is(value[1].id.length,36)})}),(0,_ava.default)("should run the app and reply to a request",async t=>{t.plan(4);// arrange
const requestsStub=_Rx.Observable.create(observer=>{observer.next({id:"uuid1",method:"cache",params:["get","settings"]})}),messengerStub={sendResponse:_sinon.default.stub(),requests:()=>requestsStub};messengerConstructorStub.withArgs("someMessageProvider").returns(messengerStub);const instance=new Aragon;instance.cache.observe=_sinon.default.stub().withArgs("0x789.settings").returns(_Rx.Observable.create(observer=>{observer.next("user settings for the voting app")})),instance.appsWithoutIdentifiers=_Rx.Observable.create(observer=>{observer.next([{appId:"some other app with a different proxy",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"}])}),utilsStub.makeProxyFromABI=proxyAddress=>({address:proxyAddress}),instance.kernelProxy={initializationBlock:0// act
};const result=await instance.runApp("someMessageProvider","0x789");// assert
/**
   * What we're testing here is that the request for getting the cache (messenger.requests())
   * is handled by the appropriate requestHandler.
   */t.true(result.shutdown!==void 0),t.true(result.setContext!==void 0),t.is(messengerStub.sendResponse.getCall(0).args[0],"uuid1"),t.is(messengerStub.sendResponse.getCall(0).args[1],"user settings for the voting app")}),(0,_ava.default)("should get the app from a proxy address",async t=>{t.plan(1);// arrange
const instance=new Aragon;instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"some other app with a different proxy",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"}])});// act
const result=await instance.getApp("0x789");// assert
t.deepEqual(result,{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"})}),(0,_ava.default)("should get the permission manager",async t=>{t.plan(1);// arrange
const instance=new Aragon;instance.permissions=_Rx.Observable.create(observer=>{observer.next({counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"im manager"}}})});// act
const result=await instance.getPermissionManager("counter","subtract");// assert
t.is(result,"im manager")}),(0,_ava.default)("should throw if no ABI is found, when calculating the transaction path",async t=>{t.plan(1);// arrange
const instance=new Aragon;// act
return instance.permissions=_Rx.Observable.create(observer=>{observer.next({counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"im manager"}}})}),instance.forwarders=_Rx.Observable.create(observer=>{observer.next([{appId:"forwarderA",proxyAddress:"0x999"}])}),instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"counterApp",kernelAddress:"0x123",abi:"abi for counterApp",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",// abi: 'abi for votingApp',
proxyAddress:"0x789"}])}),instance.calculateTransactionPath(null,"0x789").catch(err=>{t.is(err.message,"No ABI specified in artifact for 0x789")})});