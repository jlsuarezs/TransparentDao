"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_proxyquire=_interopRequireDefault(require("proxyquire")),_Rx=require("rxjs/Rx");_ava.default.beforeEach(t=>{const aragonOSCoreStub={getAragonOsInternalAppInfo:_sinon.default.stub()},messengerConstructorStub=_sinon.default.stub(),utilsStub={makeAddressMapProxy:_sinon.default.fake.returns({}),makeProxy:_sinon.default.stub(),addressesEqual:Object.is},Aragon=_proxyquire.default.noCallThru().load("./index",{"@aragon/messenger":messengerConstructorStub,"./core/aragonOS":aragonOSCoreStub,"./utils":utilsStub}).default;t.context={Aragon,aragonOSCoreStub,messengerConstructorStub,utilsStub}}),_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should throw on init if daoAddress is not a Kernel",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon("0xbaddao"),kernelProxyCallStub=_sinon.default.stub().withArgs("acl").throws();instance.kernelProxy={address:"0xbaddao",call:kernelProxyCallStub// act and assert
},await t.throwsAsync(instance.init(),{instanceOf:Error,message:`Provided daoAddress is not a DAO`})}),(0,_ava.default)("should use provided accounts",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;// act
await instance.initAccounts({providedAccounts:["0x00"]});const accounts=await instance.getAccounts();// assert
t.deepEqual(accounts,["0x00"])}),(0,_ava.default)("should get the accounts from web3",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;instance.web3={eth:{getAccounts:_sinon.default.stub().returns(["0x01","0x02"])}// act
},await instance.initAccounts({fetchFromWeb3:!0});const accounts=await instance.getAccounts();// assert
t.deepEqual(accounts,["0x01","0x02"])}),(0,_ava.default)("should not fetch the accounts if not asked",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;instance.web3={eth:{getAccounts:_sinon.default.stub().returns(["0x01","0x02"])}// act
},await instance.initAccounts({fetchFromWeb3:!1});const accounts=await instance.getAccounts();// assert
t.deepEqual(accounts,[])}),(0,_ava.default)("should get the network details from web3",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon,testNetworkId=4,testNetworkType="rinkeby";// assert
instance.web3={eth:{net:{getId:_sinon.default.stub().returns(testNetworkId),getNetworkType:_sinon.default.stub().returns(testNetworkType)}}// act
},await instance.initNetwork(),instance.network.subscribe(network=>{t.deepEqual(network,{id:testNetworkId,type:testNetworkType})})}),(0,_ava.default)("should init the ACL correctly",async t=>{const _t$context=t.context,Aragon=_t$context.Aragon,utilsStub=_t$context.utilsStub;t.plan(1);// arrange
const setPermissionEvents=_Rx.Observable.create(observer=>{observer.next({event:"SetPermission",returnValues:{app:"counter",role:"add",allowed:!0,entity:"0x1"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!0,entity:"0x1"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"add",allowed:!0,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!0,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!1,entity:"0x2"}}),observer.next({event:"SetPermission",returnValues:{app:"counter",role:"subtract",allowed:!1,entity:"0x2"}})}),changePermissionManagerEvents=_Rx.Observable.create(observer=>{observer.next({event:"ChangePermissionManager",returnValues:{app:"counter",role:"subtract",manager:"manager"}})}),instance=new Aragon;instance.kernelProxy={call:_sinon.default.stub()};const aclProxyStub={events:_sinon.default.stub()};// assert, tell ava to wait for the permissions observable to debounce
return aclProxyStub.events.withArgs("SetPermission").returns(setPermissionEvents),aclProxyStub.events.withArgs("ChangePermissionManager").returns(changePermissionManagerEvents),utilsStub.makeProxy.returns(aclProxyStub),await instance.initAcl(),new Promise(resolve=>{instance.permissions.subscribe(value=>{t.deepEqual(value,{counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"manager"}}}),setTimeout(resolve,2e3)})})}),(0,_ava.default)("should init the acl with the default acl fetched from the kernel by default",async t=>{const _t$context2=t.context,Aragon=_t$context2.Aragon,utilsStub=_t$context2.utilsStub;t.plan(3);// arrange
const instance=new Aragon,fakeAclAddress="0x321",kernelProxyCallStub=_sinon.default.stub().returns(fakeAclAddress);instance.kernelProxy={call:kernelProxyCallStub};const aclProxyStub={events:_sinon.default.stub()};// act
// assert
utilsStub.makeProxy.reset(),utilsStub.makeProxy.returns(aclProxyStub),await instance.initAcl(),t.truthy(kernelProxyCallStub.calledOnce),t.deepEqual(kernelProxyCallStub.firstCall.args,["acl"]),t.is(utilsStub.makeProxy.firstCall.args[0],fakeAclAddress)}),(0,_ava.default)("should init the acl with the provided acl",async t=>{const _t$context3=t.context,Aragon=_t$context3.Aragon,utilsStub=_t$context3.utilsStub;t.plan(2);// arrange
const instance=new Aragon,fakeAclAddress="0x321",kernelProxyCallStub=_sinon.default.stub();instance.kernelProxy={call:kernelProxyCallStub};const aclProxyStub={events:_sinon.default.stub()};// act
// assert
utilsStub.makeProxy.reset(),utilsStub.makeProxy.returns(aclProxyStub),await instance.initAcl({aclAddress:fakeAclAddress}),t.truthy(kernelProxyCallStub.notCalled),t.is(utilsStub.makeProxy.firstCall.args[0],fakeAclAddress)});const kernelAddress="0x123",appInitTestCases=[["with kernel in permissions",{"0x123":"some permissions","0x456":"some permissions","0x789":"some permissions"}],["without kernel in permissions",{"0x456":"some permissions","0x789":"some permissions"}]];appInitTestCases.forEach(([testName,permissionsObj])=>{(0,_ava.default)(`should init the apps correctly - ${testName}`,async t=>{const _t$context4=t.context,Aragon=_t$context4.Aragon,aragonOSCoreStub=_t$context4.aragonOSCoreStub;t.plan(2);// arrange
const instance=new Aragon;instance.permissions=_Rx.Observable.create(observer=>{observer.next(permissionsObj)});const appIds={"0x123":"kernel","0x456":"counterApp","0x789":"votingApp"};// act
// assert
// hack: wait 200ms for the subscribe callback above to be called,
// otherwise it will emit with the identifier set below
// act
// assert
aragonOSCoreStub.getAragonOsInternalAppInfo.withArgs(appIds[kernelAddress]).returns({abi:"abi for kernel",isAragonOsInternalApp:!0}),instance.kernelProxy={address:"0x123"},instance.getProxyValues=async appAddress=>({appId:appIds[appAddress],codeAddress:"0x",kernelAddress:"0x123",proxyAddress:appAddress}),instance.apm.getLatestVersionForContract=appId=>Promise.resolve({abi:`abi for ${appId}`}),await instance.initApps(),instance.appsWithoutIdentifiers.subscribe(value=>{t.deepEqual(value,[{abi:"abi for kernel",appId:"kernel",codeAddress:"0x",isAragonOsInternalApp:!0,kernelAddress:"0x123",proxyAddress:"0x123"},{abi:"abi for counterApp",appId:"counterApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x456"},{abi:"abi for votingApp",appId:"votingApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x789"}])}),await new Promise(resolve=>setTimeout(resolve,200)),await instance.setAppIdentifier("0x456","CNT"),instance.apps.subscribe(value=>{t.deepEqual(value,[{abi:"abi for kernel",appId:"kernel",codeAddress:"0x",isAragonOsInternalApp:!0,kernelAddress:"0x123",proxyAddress:"0x123"},{abi:"abi for counterApp",appId:"counterApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x456",identifier:"CNT"},{abi:"abi for votingApp",appId:"votingApp",codeAddress:"0x",kernelAddress:"0x123",proxyAddress:"0x789"}])})})}),(0,_ava.default)("should init the forwarders correctly",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;// act
// assert
instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"counterApp",isForwarder:!0},{appId:"votingApp",isForwarder:!1}])}),await instance.initForwarders(),instance.forwarders.subscribe(value=>{t.deepEqual(value,[{appId:"counterApp",isForwarder:!0}])})}),(0,_ava.default)("should init the notifications correctly",async t=>{const Aragon=t.context.Aragon;t.plan(7);// arrange
const instance=new Aragon;// act
// assert
instance.cache.get=_sinon.default.stub().withArgs("notifications").returns([{read:!0,title:"send"},{read:!1,title:"receive"}]),instance.cache.set=_sinon.default.stub(),await instance.initNotifications(),instance.notifications.subscribe(value=>{// only the receive notification should get an acknowledge fn attached
t.is(value[0].read,!0),t.is(value[0].title,"send"),t.is(value[1].read,!1),t.is(value[1].title,"receive"),t.is("acknowledge"in value[1],!0)}),t.is(instance.cache.set.getCall(0).args[0],"notifications"),t.is(instance.cache.set.getCall(0).args[1].length,2)}),(0,_ava.default)("should send notifications correctly",async t=>{const Aragon=t.context.Aragon;t.plan(12);// arrange
const instance=new Aragon;// act
// assert
await instance.initNotifications(),await instance.sendNotification("counterApp","add"),await instance.sendNotification("counterApp","subtract",null,null,new Date(2)),instance.notifications.subscribe(value=>{// uuidv4
t.is(value[0].app,"counterApp"),t.is(value[0].title,"subtract"),t.is(value[0].read,!1),t.is(value[0].body,null),t.is(value[0].context,null),t.is(value[0].id.length,36),t.is(value[1].app,"counterApp"),t.is(value[1].title,"add"),t.is(value[1].read,!1),t.is(value[1].body,void 0),t.deepEqual(value[1].context,{}),t.is(value[1].id.length,36)})}),(0,_ava.default)("should run the app and reply to a request",async t=>{const _t$context5=t.context,Aragon=_t$context5.Aragon,messengerConstructorStub=_t$context5.messengerConstructorStub,utilsStub=_t$context5.utilsStub;// Note: This is not a "real" unit test because the rpc handlers are not mocked
t.plan(4);// arrange
const requestsStub=_Rx.Observable.create(observer=>{observer.next({id:"uuid1",method:"cache",params:["get","settings"]})}),messengerStub={sendResponse:_sinon.default.stub(),requests:()=>requestsStub};messengerConstructorStub.withArgs("someMessageProvider").returns(messengerStub);const instance=new Aragon;instance.cache.observe=_sinon.default.stub().withArgs("0x789.settings").returns(_Rx.Observable.create(observer=>{observer.next("user settings for the voting app")})),instance.appsWithoutIdentifiers=_Rx.Observable.create(observer=>{observer.next([{appId:"some other app with a different proxy",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"}])}),utilsStub.makeProxyFromABI=proxyAddress=>({address:proxyAddress}),instance.kernelProxy={initializationBlock:0// act
};const result=await instance.runApp("someMessageProvider","0x789");// assert
/**
   * What we're testing here is that the request for getting the cache (messenger.requests())
   * is handled by the appropriate requestHandler.
   */t.true(result.shutdown!==void 0),t.true(result.setContext!==void 0),t.is(messengerStub.sendResponse.getCall(0).args[0],"uuid1"),t.is(messengerStub.sendResponse.getCall(0).args[1],"user settings for the voting app")}),(0,_ava.default)("should get the app from a proxy address",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"some other app with a different proxy",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"}])});// act
const result=await instance.getApp("0x789");// assert
t.deepEqual(result,{appId:"votingApp",kernelAddress:"0x123",abi:"abi for votingApp",proxyAddress:"0x789"})}),(0,_ava.default)("should get the permission manager",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;instance.permissions=_Rx.Observable.create(observer=>{observer.next({counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"im manager"}}})});// act
const result=await instance.getPermissionManager("counter","subtract");// assert
t.is(result,"im manager")}),(0,_ava.default)("should throw if no ABI is found, when calculating the transaction path",async t=>{const Aragon=t.context.Aragon;t.plan(1);// arrange
const instance=new Aragon;// act
return instance.permissions=_Rx.Observable.create(observer=>{observer.next({counter:{add:{allowedEntities:["0x1","0x2"]},subtract:{allowedEntities:["0x1"],manager:"im manager"}}})}),instance.forwarders=_Rx.Observable.create(observer=>{observer.next([{appId:"forwarderA",proxyAddress:"0x999"}])}),instance.apps=_Rx.Observable.create(observer=>{observer.next([{appId:"counterApp",kernelAddress:"0x123",abi:"abi for counterApp",proxyAddress:"0x456"},{appId:"votingApp",kernelAddress:"0x123",// abi: 'abi for votingApp',
proxyAddress:"0x789"}])}),instance.calculateTransactionPath(null,"0x789").catch(err=>{t.is(err.message,"No ABI specified in artifact for 0x789")})});
//# sourceMappingURL=index.test.js.map