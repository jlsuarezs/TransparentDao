"use strict";var _interopRequireWildcard=require("@babel/runtime/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"providers",{enumerable:!0,get:function get(){return _messenger.providers}}),Object.defineProperty(exports,"isNameUsed",{enumerable:!0,get:function get(){return _templates.isNameUsed}}),Object.defineProperty(exports,"ensResolve",{enumerable:!0,get:function get(){return _ens.resolve}}),exports.default=exports.setupTemplates=exports.detectProvider=void 0;var _toArray2=_interopRequireDefault(require("@babel/runtime/helpers/toArray")),_slicedToArray2=_interopRequireDefault(require("@babel/runtime/helpers/slicedToArray")),_objectSpread2=_interopRequireDefault(require("@babel/runtime/helpers/objectSpread")),_Rx=require("rxjs/Rx"),_dateFns=require("date-fns"),_v=_interopRequireDefault(require("uuid/v4")),_web=_interopRequireDefault(require("web3")),_web3Utils=require("web3-utils"),_dotProp=_interopRequireDefault(require("dot-prop")),_radspec=_interopRequireDefault(require("radspec")),_jsSha=require("js-sha3"),_apm=_interopRequireDefault(require("@aragon/apm")),_messenger=_interopRequireWildcard(require("@aragon/messenger")),handlers=_interopRequireWildcard(require("./rpc/handlers")),_evmscript=require("./evmscript"),_utils=require("./utils"),_aragonOS=require("./core/aragonOS"),_templates=_interopRequireWildcard(require("./templates")),_cache=_interopRequireDefault(require("./cache")),_interfaces=require("./interfaces"),_ens=require("./ens");// Externals
// APM
// RPC
// Utilities
// Templates
// Cache
// Interfaces
// Try to get an injected web3 provider, return a public one otherwise.
const detectProvider=()=>"undefined"==typeof web3?// eslint-disable-line
"ws://rinkeby.aragon.network:8546":web3.currentProvider;// Returns a template creator instance that can be used independently.
exports.detectProvider=detectProvider;const setupTemplates=(provider,registryAddress,from)=>{const web3=new _web.default(provider);return(0,_templates.default)(web3,(0,_apm.default)(web3,{provider,ensRegistryAddress:registryAddress}),from)};// Cache for app proxy values
exports.setupTemplates=setupTemplates;const appProxyValuesCache=(0,_utils.makeAddressMapProxy)({}),appInfoCache={};// Cache for app info, usually fetched from apm
/**
 * An Aragon wrapper.
 *
 * @param {string} daoAddress
 *        The address of the DAO.
 * @param {Object} options
 *        Wrapper options.
 * @param {*} [options.provider=ws://rinkeby.aragon.network:8546]
 *        The Web3 provider to use for blockchain communication
 * @param {String} [options.ensRegistryAddress=null]
 *        The address of the ENS registry
 * @param {Function} [options.defaultGasPriceFn=function]
 *        A factory function to provide the default gas price for transactions.
 *        It can return a promise of number string or a number string. The function
 *        has access to a recommended gas limit which can be used for custom
 *        calculations. This function can also be used to get a good gas price
 *        estimation from a 3rd party resource.
 * @example
 * const aragon = new Aragon('0xdeadbeef')
 *
 * // Initialises the wrapper and logs the installed apps
 * aragon.init(() => {
 *   aragon.apps.subscribe(
 *     (apps) => console.log(apps)
 *   )
 * })
 */class Aragon{constructor(daoAddress,options={}){const defaultOptions={provider:detectProvider(),apm:{},defaultGasPriceFn:()=>(0,_web3Utils.toWei)("20","gwei")};// Set up Web3
// Set up APM
// Set up the kernel proxy
// Set up cache
options=Object.assign(defaultOptions,options),this.web3=new _web.default(options.provider),this.apm=(0,_apm.default)(this.web3,Object.assign(options.apm,{ensRegistryAddress:options.ensRegistryAddress,provider:options.provider})),this.kernelProxy=(0,_utils.makeProxy)(daoAddress,"Kernel",this.web3),this.cache=new _cache.default(daoAddress),this.defaultGasPriceFn=options.defaultGasPriceFn}/**
   * Initialise the wrapper.
   *
   * @param {?Array<string>} [accounts=null] An optional array of accounts that the user controls
   * @return {Promise<void>}
   */async init(accounts=null){await this.initAccounts(accounts),await this.kernelProxy.updateInitializationBlock(),await this.initAcl(),this.initApps(),this.initForwarders(),this.initNotifications(),this.transactions=new _Rx.Subject}/**
   * Initialise the accounts observable.
   *
   * @param {?Array<string>} [accounts=null] An optional array of accounts that the user controls
   * @return {Promise<void>}
   */async initAccounts(accounts){this.accounts=new _Rx.ReplaySubject(1),null===accounts&&(accounts=await this.web3.eth.getAccounts()),this.setAccounts(accounts)}/**
   * Initialise the ACL (Access Control List).
   *
   * @return {Promise<void>}
   */async initAcl(){// Set up ACL proxy
const aclAddress=await this.kernelProxy.call("acl");this.aclProxy=(0,_utils.makeProxy)(aclAddress,"ACL",this.web3,this.kernelProxy.initializationBlock);const CHANGE_PERMISSION_MANAGER_EVENT="ChangePermissionManager",aclObservables=["SetPermission",CHANGE_PERMISSION_MANAGER_EVENT].map(event=>this.aclProxy.events(event));// Set up permissions observable
// Permissions Object:
// app -> role -> { manager, allowedEntities -> [ entities with permission ] }
this.permissions=_Rx.Observable.merge(...aclObservables)// Keep track of all the types of events that have been processed
.scan(([permissions,eventSet],event)=>{const eventData=event.returnValues,appPermissions=permissions[eventData.app]||{};// NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions
if(event.event==="SetPermission"){const key=`${eventData.role}.allowedEntities`,permissionsForRole=new Set(_dotProp.default.get(appPermissions,key,[]));// Converts to and from a set to avoid duplicated entities
eventData.allowed?permissionsForRole.add(eventData.entity):permissionsForRole.delete(eventData.entity),_dotProp.default.set(appPermissions,key,Array.from(permissionsForRole))}return event.event===CHANGE_PERMISSION_MANAGER_EVENT&&_dotProp.default.set(appPermissions,`${eventData.role}.manager`,eventData.manager),permissions[eventData.app]=appPermissions,[permissions,eventSet.add(event.event)]},[(0,_utils.makeAddressMapProxy)({}),new Set])// Skip until we have received events from all event subscriptions
// Note that this is safe as the ACL will always have to emit both
// ChangePermissionManager and SetPermission events every time a
// permission is created
.skipWhile(([permissions,eventSet])=>eventSet.size<aclObservables.length).map(([permissions])=>permissions)// Throttle so it only continues after 30ms without new values
// Avoids DDOSing subscribers as during initialization there may be
// hundreds of events processed in a short timespan
.debounceTime(30).publishReplay(1),this.permissions.connect()}/**
   * Get proxy metadata (`appId`, address of the kernel, ...).
   *
   * @param  {string} proxyAddress
   *         The address of the proxy to get metadata from
   * @return {Promise<Object>}
   */async getAppProxyValues(proxyAddress){// This function caches information about the AppProxy, as it is called for
// all the apps everytime a permission changes and this data won't change
// once it's fetched
const cachedValue=appProxyValuesCache[proxyAddress];if(cachedValue&&cachedValue.kernelAddress&&cachedValue.appId&&cachedValue.codeAddress)return cachedValue;const appProxy=(0,_utils.makeProxy)(proxyAddress,"AppProxy",this.web3,this.kernelProxy.initializationBlock),appProxyValues=await Promise.all([appProxy.call("kernel").catch(()=>null),appProxy.call("appId").catch(()=>null),appProxy.call("implementation").catch(()=>appProxy// Fallback to old non-ERC897 proxy implementation
.call("getCode").catch(()=>null)),appProxy.call("isForwarder").catch(()=>!1)]).then(values=>({proxyAddress,kernelAddress:values[0],appId:values[1],codeAddress:values[2],isForwarder:values[3]}));return appProxyValuesCache[proxyAddress]=appProxyValues,appProxyValues}/**
   * Check if an object is an app.
   *
   * @param  {Object}  app
   * @return {boolean}
   */isApp(app){return app.kernelAddress&&(0,_utils.addressesEqual)(app.kernelAddress,this.kernelProxy.address)}/**
   * Initialise apps observable.
   *
   * @return {void}
   */initApps(){// TODO: Refactor this a bit because it's pretty much an eye sore
this.identifiers=new _Rx.Subject,this.appsWithoutIdentifiers=this.permissions.map(Object.keys).map(addresses=>addresses.filter(address=>!(0,_utils.addressesEqual)(address,this.kernelProxy.address))).switchMap(appAddresses=>Promise.all(appAddresses.map(app=>this.getAppProxyValues(app)))).map(appMetadata=>appMetadata.filter(app=>this.isApp(app))).flatMap(apps=>Promise.all(apps.map(async app=>{if(!app.appId||!app.codeAddress)return app;const cacheKey=`${app.appId}.${app.codeAddress}`,cachedAppInfo=_dotProp.default.get(appInfoCache,cacheKey),appInfo=cachedAppInfo||(0,_aragonOS.getAragonOsInternalAppInfo)(app.appId)||(await this.apm.getLatestVersionForContract(app.appId,app.codeAddress)// Just silence any errors
.catch(()=>{}));return!cachedAppInfo&&appInfo&&_dotProp.default.set(appInfoCache,cacheKey,appInfo),Object.assign(app,appInfo)})))// Replaying the last emitted value is necessary for this.apps' combineLatest to not rerun
// this entire operator chain on identifier emits (doing so causes unnecessary apm fetches)
.publishReplay(1),this.appsWithoutIdentifiers.connect(),this.apps=this.appsWithoutIdentifiers.combineLatest(this.identifiers.scan((identifiers,{address,identifier})=>Object.assign(identifiers,{[address]:identifier}),{}).startWith({}),function(apps,identifiers){return apps.map(app=>identifiers[app.proxyAddress]?Object.assign(app,{identifier:identifiers[app.proxyAddress]}):app)}).publishReplay(1),this.apps.connect()}/**
   * Set the identifier of an app.
   *
   * @param {string} address The proxy address of the app
   * @param {string} identifier The identifier of the app
   * @return {void}
   */setAppIdentifier(address,identifier){this.identifiers.next({address,identifier})}/**
   * Initialise forwarder observable.
   *
   * @return {void}
   */initForwarders(){this.forwarders=this.apps.map(apps=>apps.filter(app=>app.isForwarder)).publishReplay(1),this.forwarders.connect()}/**
   * Initialise the notifications observable.
   *
   * @return {void}
   */initNotifications(){// If the cached notifications doesn't exist or isn't an array, set it to an empty one
let cached=this.cache.get("notifications");Array.isArray(cached)?cached.forEach(notification=>{notification&&!notification.read&&(notification.acknowledge=()=>this.acknowledgeNotification(notification.id))}):cached=[],this.notifications=new _Rx.BehaviorSubject(cached).scan((notifications,{modifier,notification})=>modifier(notifications,notification)).do(notifications=>this.cache.set("notifications",notifications)).publishReplay(1),this.notifications.connect()}/**
   * Send a notification.
   *
   * @param {string} app   The address of the app sending the notification
   * @param {string} title The notification title
   * @param {string} body  The notification body
   * @param {object} [context={}] The application context to send back if the notification is clicked
   * @param  {Date}  [date=new Date()] The date the notification was sent
   * @return {void}
   */sendNotification(app,title,body,context={},date=new Date){const id=(0,_v.default)();this.notifications.next({modifier:(notifications,notification)=>{// Find the first notification that's not before this new one
// and insert ahead of it if it exists
const newNotificationIndex=notifications.findIndex(notification=>!(0,_dateFns.isBefore)(new Date(notification.date),date));return-1===newNotificationIndex?[...notifications,notification]:[...notifications.slice(0,newNotificationIndex),notification,...notifications.slice(newNotificationIndex)]},notification:(0,_objectSpread2.default)({},{app,body,context,date,id,title,read:!1},{acknowledge:()=>this.acknowledgeNotification(id)})})}/**
   * Acknowledge a notification.
   *
   * @param {string} id The notification's id
   * @return {void}
   */acknowledgeNotification(id){this.notifications.next({modifier:notifications=>{const notificationIndex=notifications.findIndex(notification=>notification.id===id),newNotifications=[...notifications];// Copy the old notifications and replace the old notification with a read version
return newNotifications[notificationIndex]=(0,_objectSpread2.default)({},notifications[notificationIndex],{read:!0,acknowledge:()=>{}}),newNotifications}})}/**
   * Clears a notification.
   *
   * @param {string} id The notification's id
   * @return {void}
   */clearNotification(id){this.notifications.next({modifier:notifications=>notifications.filter(notification=>notification.id!==id)})}/**
   * Clears all notifications.
   *
   * @return {void}
   */clearNotifications(){this.notifications.next({modifier:()=>[]})}/**
   * Run an app.
   *
   * @param  {Object} sandboxMessengerProvider
   *         An object that can communicate with the app sandbox via Aragon RPC.
   * @param  {string} proxyAddress
   *         The address of the app proxy.
   * @return {Object}
   */runApp(sandboxMessengerProvider,proxyAddress){// App context helper function
// Set up messenger
const messenger=new _messenger.default(sandboxMessengerProvider),proxy$=this.appsWithoutIdentifiers.map(apps=>apps.find(app=>(0,_utils.addressesEqual)(app.proxyAddress,proxyAddress)))// TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw
.map(app=>(0,_utils.makeProxyFromABI)(app.proxyAddress,app.abi,this.web3,this.kernelProxy.initializationBlock)),request$=_Rx.Observable.combineLatest(messenger.requests(),proxy$,(request,proxy)=>({request,proxy,wrapper:this}))// Use the same request$ result in each handler
// Turns request$ into a subject
.publishReplay(1);// Get the application proxy
// NOTE: we **CANNOT** use this.apps here, as it'll trigger an endless spiral of infinite streams
request$.connect();// Register request handlers
const shutdown=handlers.combineRequestHandlers(handlers.createRequestHandler(request$,"cache",handlers.cache),handlers.createRequestHandler(request$,"events",handlers.events),handlers.createRequestHandler(request$,"intent",handlers.intent),handlers.createRequestHandler(request$,"call",handlers.call),handlers.createRequestHandler(request$,"notification",handlers.notifications),handlers.createRequestHandler(request$,"external_call",handlers.externalCall),handlers.createRequestHandler(request$,"external_events",handlers.externalEvents),handlers.createRequestHandler(request$,"identify",handlers.identifier),handlers.createRequestHandler(request$,"accounts",handlers.accounts),handlers.createRequestHandler(request$,"describe_script",handlers.describeScript),handlers.createRequestHandler(request$,"web3_eth",handlers.web3Eth)).subscribe(response=>messenger.sendResponse(response.id,response.payload));return{shutdown,setContext:function(context){return messenger.send("context",[context])}}}/**
   * Set the available accounts for the current user.
   *
   * @param {Array<string>} accounts
   * @return {void}
   */setAccounts(accounts){this.accounts.next(accounts)}/**
   * Get the available accounts for the current user.
   *
   * @return {Promise<Array<string>>} An array of addresses
   */getAccounts(){return this.accounts.take(1).toPromise()}/**
   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each step in the path
   * @return {Promise<string>} transaction hash
   */performTransactionPath(transactionPath){return new Promise((resolve,reject)=>{this.transactions.next({transaction:transactionPath[0],path:transactionPath,accept(transactionHash){resolve(transactionHash)},reject(err){reject(err||new Error("The transaction was not signed"))}})})}/**
   * Performs an action on the ACL using transaction pathing
   *
   * @param {string} method
   * @param {Array<*>} params
   * @return {Promise<string>} transaction hash
   */async performACLIntent(method,params){const path=await this.getACLTransactionPath(method,params);return this.performTransactionPath(path)}/**
   * Looks for app with the provided proxyAddress and returns its app object if found
   *
   * @param {string} proxyAddress
   * @return {Promise<Object>} The app object
   */getApp(proxyAddress){return this.apps.map(apps=>apps.find(app=>(0,_utils.addressesEqual)(app.proxyAddress,proxyAddress))).take(1).toPromise()}/**
   * Decodes an EVM callscript and returns the transaction path it describes.
   *
   * @param  {string} script
   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path
   */decodeTransactionPath(script){// TODO: Support callscripts with multiple transactions in one (i.e. one ID, multiple destinations)
function decodePathSegment(script){script=script.substr(10);// Get address
const destination=`0x${script.substr(0,40)}`;script=script.substr(40);// Get data
const dataLength=2*parseInt(`0x${script.substr(0,8)}`);script=script.substr(8);const data=`0x${script.substr(0,dataLength)}`;return script=script.substr(dataLength),{to:destination,data}}let scriptId=script.substr(0,10);if(scriptId!==_evmscript.CALLSCRIPT_ID)throw new Error(`Unknown script ID ${scriptId}`);let path=[];for(;script.startsWith(_evmscript.CALLSCRIPT_ID);){const segment=decodePathSegment(script);// Set script
// Push segment
script=segment.data,path.push(segment)}return path}/**
   * Calculate the transaction path for a transaction to `destination`
   * that invokes `methodName` with `params`.
   *
   * @param  {string} destination
   * @param  {string} methodName
   * @param  {Array<*>} params
   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action
   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path
   */async getTransactionPath(destination,methodName,params,finalForwarder){const accounts=await this.getAccounts();for(let account of accounts){const path=await this.calculateTransactionPath(account,destination,methodName,params,finalForwarder);if(0<path.length)return this.describeTransactionPath(path)}return[]}/**
   * Get the permission manager for an `app`'s and `role`.
   *
   * @param {string} appAddress
   * @param {string} roleHash
   * @return {Promise<string>} The permission manager
   */async getPermissionManager(appAddress,roleHash){const permissions=await this.permissions.take(1).toPromise(),appPermissions=permissions[appAddress];return _dotProp.default.get(appPermissions,`${roleHash}.manager`)}/**
   * Calculates transaction path for performing a method on the ACL
   *
   * @param {string} method
   * @param {Array<*>} params
   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path
   */async getACLTransactionPath(method,params){const aclAddr=this.aclProxy.address,acl=await this.getApp(aclAddr),functionArtifact=acl.functions.find(({sig})=>sig.split("(")[0]===method);if(!functionArtifact)throw new Error(`Method ${method} not found on ACL artifact`);if(functionArtifact.roles&&0!==functionArtifact.roles.length)// createPermission can be done with regular transaction pathing (it has a regular ACL role)
return this.getTransactionPath(aclAddr,method,params);else{// All other ACL functions don't have a role, the manager needs to be provided to aid transaction pathing
// Inspect ABI to find the position of the 'app' and 'role' parameters needed to get the permission manager
const methodABI=acl.abi.find(item=>item.name===method&&"function"===item.type);if(!methodABI)throw new Error(`Method ${method} not found on ACL ABI`);const inputNames=methodABI.inputs.map(input=>input.name),appIndex=inputNames.indexOf("_app"),roleIndex=inputNames.indexOf("_role");if(-1===appIndex||-1===roleIndex)throw new Error(`Method ${method} doesn't take _app and _role as input. Permission manager cannot be found.`);const manager=await this.getPermissionManager(params[appIndex],params[roleIndex]);return this.getTransactionPath(aclAddr,method,params,manager)}}/**
   * Use radspec to create a human-readable description for each transaction in the given `path`
   *
   * @param  {Array<Object>} path
   * @return {Promise<Array<Object>>} The given `path`, with descriptions included at each step
   */describeTransactionPath(path){return Promise.all(path.map(async step=>{const app=await this.getApp(step.to);// No app artifact
if(!app)return step;// Missing methods in artifact
if(!app.functions)return step;// Find the method
const methodId=step.data.substr(2,8),method=app.functions.find(method=>(0,_jsSha.keccak256)(method.sig).substr(0,8)===methodId);// Method does not exist in artifact
if(!method)return step;const expression=method.notice;// No expression
return expression?Object.assign(step,{description:await _radspec.default.evaluate(expression,{abi:app.abi,transaction:step},{ethNode:this.web3.currentProvider}),name:app.name,identifier:app.identifier}):step}))}/**
   * Whether the `sender` can use the `forwarder` to invoke `script`.
   *
   * @param  {string} forwarder
   * @param  {string} sender
   * @param  {string} script
   * @return {Promise<bool>}
   */canForward(forwarder,sender,script){const canForward=new this.web3.eth.Contract((0,_interfaces.getAbi)("aragon/Forwarder"),forwarder).methods.canForward;return canForward(sender,script).call().catch(()=>!1)}getDefaultGasPrice(gasLimit){return this.defaultGasPriceFn(gasLimit)}/**
   * Calculates and applies the gas limit and gas price for a transaction
   *
   * @param  {Object} transaction
   * @param  {bool} isForwarding
   * @return {Promise<Object>} The transaction with the gas limit and gas price added.
   *                           If the transaction fails from the estimateGas check, the promise will
   *                           be rejected with the error.
   */async applyTransactionGas(transaction,isForwarding=!1){// NOTE: estimateGas mutates the argument object and transforms the address to lowercase
// so this is a hack to make sure checksums are not destroyed
// Also, at the same time it's a hack for checking if the call will revert,
// since `eth_call` returns `0x` if the call fails and if the call returns nothing.
// So yeah...
const estimatedGasLimit=await this.web3.eth.estimateGas((0,_objectSpread2.default)({},transaction,{gas:void 0})),recommendedGasLimit=await(0,_utils.getRecommendedGasLimit)(this.web3,estimatedGasLimit);return(!transaction.gas||isForwarding&&transaction.gas<recommendedGasLimit)&&(transaction.gas=recommendedGasLimit),transaction.gasPrice||(transaction.gasPrice=await this.getDefaultGasPrice(transaction.gas)),transaction}/**
   * Calculate the transaction path for a transaction to `destination`
   * that invokes `methodName` with `params`.
   *
   * @param  {string} sender
   * @param  {string} destination
   * @param  {string} methodName
   * @param  {Array<*>} params
   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.
   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors
   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path
   */async calculateTransactionPath(sender,destination,methodName,params,finalForwarder){const finalForwarderProvided=(0,_web3Utils.isAddress)(finalForwarder),permissions=await this.permissions.take(1).toPromise(),app=await this.getApp(destination);if(!app)throw new Error(`No artifact found for ${destination}`);const jsonInterface=app.abi;if(!jsonInterface)throw new Error(`No ABI specified in artifact for ${destination}`);const methodABI=app.abi.find(method=>method.name===methodName);if(!methodABI)throw new Error(`${methodName} not found on ABI for ${destination}`);let transactionOptions={};// If an extra parameter has been provided, it is the transaction options if it is an object
if(methodABI.inputs.length+1===params.length&&"object"==typeof params[params.length-1]){const options=params.pop();transactionOptions=(0,_objectSpread2.default)({},transactionOptions,options)}// The direct transaction we eventually want to perform
const directTransaction=(0,_objectSpread2.default)({},transactionOptions,{// Options are overwriten by the values below
from:sender,to:destination,data:this.web3.eth.abi.encodeFunctionCall(methodABI,params)});let appsWithPermissionForMethod=[];// Only try to perform direct transaction if no final forwarder is provided or
// if the final forwarder is the sender
if(!finalForwarderProvided||finalForwarder===sender){const methods=app.functions;if(!methods)throw new Error(`No functions specified in artifact for ${destination}`);// Find method description from the function signatures
const method=methods.find(method=>method.sig.split("(")[0]===methodName);if(!method)throw new Error(`No method named ${methodName} on ${destination}`);// If the method has no ACL requirements, we assume we
// can perform the action directly
if(0===method.roles.length)return[directTransaction];// TODO: Support multiple needed roles?
const roleSig=app.roles.find(role=>role.id===method.roles[0]).bytes,permissionsForDestination=permissions[destination];// No one has access
if(appsWithPermissionForMethod=_dotProp.default.get(permissionsForDestination,`${roleSig}.allowedEntities`,[]),0===appsWithPermissionForMethod.length)return[];try{// `applyTransactionGas` can throw if the transaction will fail
// if that happens, we will try to find a transaction path through a forwarder
return[await this.applyTransactionGas(directTransaction)]}catch(_){}}const forwarders=await this.forwarders.take(1).toPromise().then(forwarders=>forwarders.map(forwarder=>forwarder.proxyAddress));let forwardersWithPermission;if(finalForwarderProvided){if(!(0,_utils.includesAddress)(forwarders,finalForwarder))return[];forwardersWithPermission=[finalForwarder]}else// Find forwarders with permission to perform the action
forwardersWithPermission=forwarders.filter(forwarder=>(0,_utils.includesAddress)(appsWithPermissionForMethod,forwarder));return this.calculateForwardingPath(sender,destination,directTransaction,forwardersWithPermission)}/**
   * Calculate the forwarding path for a transaction to `destination`
   * that invokes `directTransaction`.
   *
   * @param  {string} sender
   * @param  {string} destination
   * @param  {Object} directTransaction
   * @param  {string} [forwardersWithPermission]
   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path
   */async calculateForwardingPath(sender,destination,directTransaction,forwardersWithPermission){// No forwarders can perform the requested action
if(0===forwardersWithPermission.length)return[];// TODO: No need for contract?
// A helper method to create a transaction that calls `forward` on a forwarder with `script`
const forwardMethod=new this.web3.eth.Contract((0,_interfaces.getAbi)("aragon/Forwarder")).methods.forward,createForwarderTransaction=(forwarderAddress,script)=>(0,_objectSpread2.default)({},directTransaction,{// Options are overwriten by the values below
from:sender,to:forwarderAddress,data:forwardMethod(script).encodeABI()});// Check if one of the forwarders that has permission to perform an action
// with `sig` on `address` can forward for us directly
for(const forwarder of forwardersWithPermission){let script=(0,_evmscript.encodeCallScript)([directTransaction]);if(await this.canForward(forwarder,sender,script)){const transaction=createForwarderTransaction(forwarder,script);// TODO: recover if applying gas fails here
return[await this.applyTransactionGas(transaction,!0),directTransaction]}}// Get a list of all forwarders (excluding the forwarders with direct permission)
const forwarders=await this.forwarders.take(1).toPromise().then(forwarders=>forwarders.map(forwarder=>forwarder.proxyAddress).filter(forwarder=>!(0,_utils.includesAddress)(forwardersWithPermission,forwarder))),queue=forwardersWithPermission.map(forwarderWithPermission=>[[createForwarderTransaction(forwarderWithPermission,(0,_evmscript.encodeCallScript)([directTransaction])),directTransaction],forwarders]);// Set up the path finding queue
// The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>
// In other words: it is an array of tuples, where the first index of the tuple
// is the current path and the second index of the tuple is the
// queue (a list of unexplored forwarder addresses) for that path
// Find the shortest path
do{const _queue$shift=queue.shift(),_queue$shift2=(0,_slicedToArray2.default)(_queue$shift,2),path=_queue$shift2[0],_queue$shift2$=(0,_toArray2.default)(_queue$shift2[1]),forwarder=_queue$shift2$[0],nextQueue=_queue$shift2$.slice(1);// Skip paths longer than 10
if(10<path.length)continue;// Get the previous forwarder address
const previousForwarder=path[0].to;// Encode the previous transaction into an EVM callscript
let script=(0,_evmscript.encodeCallScript)([path[0]]);if(await this.canForward(previousForwarder,forwarder,script)){if(await this.canForward(forwarder,sender,script)){// The previous forwarder can forward a transaction for this forwarder,
// and this forwarder can forward for our address, so we have found a path
const transaction=createForwarderTransaction(forwarder,script);// `applyTransactionGas` is only done for the transaction that will be executed
// TODO: recover if applying gas fails here
return[await this.applyTransactionGas(transaction,!0),...path]}// The previous forwarder can forward a transaction for this forwarder,
// but this forwarder can not forward for our address, so we add it as a
// possible path in the queue for later exploration.
// TODO(onbjerg): Should `forwarders` be filtered to exclude forwarders in the path already?
queue.push([[createForwarderTransaction(forwarder,script),...path],forwarders])}// We add the current path on the back of the queue again, but we shorten
// the list of possible forwarders.
queue.push([path,nextQueue])}while(queue.length);return[]}}exports.default=Aragon;