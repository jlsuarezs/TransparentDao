"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.isNameUsed=void 0;var _objectSpread2=_interopRequireDefault(require("@babel/runtime/helpers/objectSpread")),_slicedToArray2=_interopRequireDefault(require("@babel/runtime/helpers/slicedToArray")),_ens=require("../ens"),_utils=require("../utils");const zeroAddress="0x0000000000000000000000000000000000000000",templates={democracy:{name:"Democracy",appId:"democracy-kit.aragonpm.eth"},multisig:{name:"Multisig",appId:"multisig-kit.aragonpm.eth"}/**
 * @name Templates
 * @function
 * @description Factory for DAO templates.
 *
 * @param {string} from
 *        The address of the account using the factory.
 * @param {Object} options
 *        Template factory options.
 * @param {Object} options.apm
 *        apm.js instance
 * @param {Function} options.defaultGasPriceFn
 *        A factory function to provide the default gas price for transactions.
 *        It can return a promise of number string or a number string. The function
 *        has access to a recommended gas limit which can be used for custom
 *        calculations. This function can also be used to get a good gas price
 *        estimation from a 3rd party resource.
 * @param {Object} options.web3
 *        Web3 instance
 * @return {Object} Factory object
 */},Templates=(from,{apm,defaultGasPriceFn,web3})=>{const newToken=async(template,{params,options={}})=>{const _params=(0,_slicedToArray2.default)(params,2),tokenName=_params[0],tokenSymbol=_params[1],call=template.methods.newToken(tokenName,tokenSymbol),receipt=await call.send((0,_objectSpread2.default)({from},(await applyCallGasOptions(call,options))));return receipt.events.DeployToken.returnValues},newInstance=async(template,{params,options={}})=>{const call=template.methods.newInstance(...params),receipt=await call.send((0,_objectSpread2.default)({from},(await applyCallGasOptions(call,options))));return receipt.events.DeployInstance.returnValues},applyCallGasOptions=async(call,txOptions={})=>{if(!txOptions.gas){const estimatedGasLimit=await call.estimateGas({from}),recommendedGasLimit=await(0,_utils.getRecommendedGasLimit)(web3,estimatedGasLimit,{gasFuzzFactor:1.1});txOptions.gas=recommendedGasLimit}return txOptions.gasPrice||(txOptions.gasPrice=await defaultGasPriceFn(txOptions.gas)),txOptions};return{/**
     * Create a new DAO by sending two transactions:
     *
     *   1. Create a new token
     *   2. Create a new instance of a template (the token is cached in the template contract)
     *
     * @param {string} templateName name of the template to use
     * @param {Object} tokenParams parameters for the token creation transaction
     * @param {Array<string>} tokenParams.params array of [<Token name>, <Token symbol>]
     * @param {Object} [tokenParams.options={}] transaction options
     * @param {Object} instanceParams parameters for the DAO creation transaction
     * @param {Array<string>} tokenParams.params parameters for the template's `newDAO()` method
     * @param {Object} [instanceParams.options={}] transaction options
     * @return {Array<Object>} return values for `DeployEvent` and `DeployInstance`
     */newDAO:async(templateName,tokenParams,instanceParams)=>{const tmplObj=templates[templateName];if(!tmplObj)throw new Error("No template found for that name");const _ref=await apm.getLatestVersion(tmplObj.appId),contractAddress=_ref.contractAddress,abi=_ref.abi;if(!contractAddress)throw new Error(`No contract found on APM for template '${templateName}'`);if(!abi)throw new Error(`Could not fetch ABI for template '${templateName}'`);const template=new web3.eth.Contract(abi,contractAddress),token=await newToken(template,tokenParams),instance=await newInstance(template,instanceParams);return[token,instance]}}},isNameUsed=async(name,opts={})=>{try{const addr=await(0,_ens.resolve)(`${name}.aragonid.eth`,opts);return addr!==zeroAddress}catch(err){if("ENS name not defined."===err.message)return!1;throw new Error(`ENS couldnâ€™t resolve the domain: ${name}.aragonid.eth`)}};// Maybe we can even do a simple markup language that aragon/aragon interprets
exports.isNameUsed=isNameUsed;var _default=Templates;exports.default=_default;
//# sourceMappingURL=index.js.map