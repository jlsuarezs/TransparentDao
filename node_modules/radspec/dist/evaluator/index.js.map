{"version":3,"sources":["../../src/evaluator/index.js"],"names":["ABI","require","Eth","Web3Utils","BN","types","Helpers","TypedValue","constructor","type","value","isInteger","isBN","isAddress","Error","toChecksumAddress","toString","Evaluator","ast","bindings","ethNode","to","eth","helpers","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","Math","ceil","body","join","length","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","bothTypesBytes","bytes","isType","toBN","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","hasOwnProperty","binding","target","checkAddressChecksum","inputs","outputs","call","encodeFunctionCall","name","callee","input","returnType","data","then","decodeParameter","helperName","exists","result","execute","evaluate","evaluatedNodes","msg","module","exports","options"],"mappings":"aAAA;;QAIMA,CAAAA,GAAG,CAAGC,OAAO,CAAC,cAAD,C,CACbC,GAAG,CAAGD,OAAO,CAAC,UAAD,C,CACbE,SAAS,CAAGF,OAAO,CAAC,YAAD,C,CACnBG,EAAE,CAAGH,OAAO,CAAC,OAAD,C,CACZI,KAAK,CAAGJ,OAAO,CAAC,UAAD,C,UACDA,OAAO,CAAC,YAAD,C,CAAnBK,O,UAAAA,O,CAER;;;;;;;;GASA,KAAMC,CAAAA,UAAW,CACfC,WAAW,CAAEC,IAAF,CAAQC,KAAR,CAAe,CAQxB,GAPA,KAAKD,IAAL,CAAYA,IAOZ,CANA,KAAKC,KAAL,CAAaA,KAMb,CAJIL,KAAK,CAACM,SAAN,CAAgB,KAAKF,IAArB,GAA8B,CAACL,EAAE,CAACQ,IAAH,CAAQ,KAAKF,KAAb,CAInC,GAHE,KAAKA,KAAL,CAAa,GAAIN,CAAAA,EAAJ,CAAO,KAAKM,KAAZ,CAGf,EAAkB,SAAd,QAAKD,IAAT,CAA6B,CAC3B,GAAI,CAACN,SAAS,CAACU,SAAV,CAAoB,KAAKH,KAAzB,CAAL,CACE,KAAM,IAAII,CAAAA,KAAJ,CAAW,oBAAmB,KAAKJ,KAAM,GAAzC,CAAN,CAEF,KAAKA,KAAL,CAAaP,SAAS,CAACY,iBAAV,CAA4B,KAAKL,KAAjC,CACd,CACF,CAED;;;;KAKAM,QAAQ,EAAI,CACV,MAAO,MAAKN,KAAL,CAAWM,QAAX,EACR,CAxBc,CA2BjB;;;;;;;;;;;GAYA,KAAMC,CAAAA,SAAU,CACdT,WAAW,CAAEU,GAAF,CAAOC,QAAP,CAAiB,CAAEC,OAAF,CAAWC,EAAX,EAAkB,EAAnC,CAAuC,CAChD,KAAKH,GAAL,CAAWA,GADqC,CAEhD,KAAKC,QAAL,CAAgBA,QAFgC,CAGhD,KAAKG,GAAL,CAAW,GAAIpB,CAAAA,GAAJ,CAAQkB,OAAO,EAAI,2BAAnB,CAHqC,CAIhD,KAAKC,EAAL,CAAUA,EAAE,EAAI,GAAId,CAAAA,UAAJ,CAAe,SAAf,CAA0Bc,EAA1B,CAJgC,CAKhD,KAAKE,OAAL,CAAe,GAAIjB,CAAAA,OAAJ,CAAY,KAAKgB,GAAjB,CAChB,CAED;;;;;KAMA,KAAME,CAAAA,aAAN,CAAqBC,KAArB,CAA4B,CAC1B,MAAOC,CAAAA,OAAO,CAACC,GAAR,CACLF,KAAK,CAACG,GAAN,CAAU,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAAV,CADK,CAGR,CAED;;;;;KAMA,KAAMD,CAAAA,YAAN,CAAoBE,IAApB,CAA0B,eAsBPC,IAAI,CAACC,IAtBE,CACxB,GAAkB,qBAAd,GAAAF,IAAI,CAACtB,IAAT,CACE,MAAO,CAAC,KAAM,MAAKe,aAAL,CAAmBO,IAAI,CAACG,IAAxB,CAAP,EAAsCC,IAAtC,CAA2C,GAA3C,CAAP,CAGF,GAAkB,mBAAd,GAAAJ,IAAI,CAACtB,IAAT,CACE,MAAO,MAAKoB,YAAL,CAAkBE,IAAI,CAACG,IAAvB,CAAP,CAGF,GAAkB,oBAAd,GAAAH,IAAI,CAACtB,IAAT,CACE,MAAO,IAAIF,CAAAA,UAAJ,CAAe,QAAf,CAAyBwB,IAAI,CAACrB,KAA9B,CAAP,CAGF,GAAkB,eAAd,GAAAqB,IAAI,CAACtB,IAAT,CACE,MAAO,IAAIF,CAAAA,UAAJ,CAAe,QAAf,CAAyBwB,IAAI,CAACrB,KAAL,EAAc,EAAvC,CAAP,CAGF,GAAkB,eAAd,GAAAqB,IAAI,CAACtB,IAAT,CACE,MAAO,IAAIF,CAAAA,UAAJ,CAAe,QAAf,CAAyBwB,IAAI,CAACrB,KAA9B,CAAP,CAGF,GAAkB,cAAd,GAAAqB,IAAI,CAACtB,IAAT,CAAkC,CAChC,KAAM2B,CAAAA,MAAM,CAAG,UAAU,CAACL,IAAI,CAACrB,KAAL,CAAW0B,MAAX,CAAoB,CAArB,EAA0B,CAApC,CAAf,CAKA,MAJa,GAAT,CAAAA,MAIJ,EAHE,KAAKC,KAAL,CAAW,4CAAX,CAGF,CAAO,GAAI9B,CAAAA,UAAJ,CAAgB,QAAO6B,MAAO,EAA9B,CAAiCL,IAAI,CAACrB,KAAtC,CACR,CAED,GAAkB,aAAd,GAAAqB,IAAI,CAACtB,IAAT,CACE,MAAO,IAAIF,CAAAA,UAAJ,CAAe,MAAf,CAAsC,MAAf,GAAAwB,IAAI,CAACrB,KAA5B,CAAP,CAGF,GAAkB,kBAAd,GAAAqB,IAAI,CAACtB,IAAT,CAAsC,MAC9B6B,CAAAA,IAAI,CAAG,KAAM,MAAKT,YAAL,CAAkBE,IAAI,CAACO,IAAvB,CADiB,CAE9BC,KAAK,CAAG,KAAM,MAAKV,YAAL,CAAkBE,IAAI,CAACQ,KAAvB,CAFgB,CAIpC;AACA,GAAI,CAAe,QAAd,GAAAD,IAAI,CAAC7B,IAAL,EACY,QAAf,GAAA8B,KAAK,CAAC9B,IADJ,GAEgB,MAAlB,GAAAsB,IAAI,CAACS,QAFP,CAGE,MAAO,IAAIjC,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWM,QAAX,GAAwBuB,KAAK,CAAC7B,KAAN,CAAYM,QAAZ,EAAjD,CAAP,CAGF;AAMA,OALKX,KAAK,CAACM,SAAN,CAAgB2B,IAAI,CAAC7B,IAArB,CAAD,EACDJ,KAAK,CAACM,SAAN,CAAgB4B,KAAK,CAAC9B,IAAtB,CAIH,EAHE,KAAK4B,KAAL,CAAY,sCAAqCN,IAAI,CAACS,QAAS,4BAA2BF,IAAI,CAAC7B,IAAK,UAAS8B,KAAK,CAAC9B,IAAK,GAAxH,CAGF,CAAQsB,IAAI,CAACS,QAAb,EACE,IAAK,MAAL,CACE,MAAO,IAAIjC,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAW+B,GAAX,CAAeF,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,IAAK,OAAL,CACE,MAAO,IAAIH,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWgC,GAAX,CAAeH,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,IAAK,MAAL,CACE,MAAO,IAAIH,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWiC,GAAX,CAAeJ,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,IAAK,OAAL,CACE,MAAO,IAAIH,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWkC,GAAX,CAAeL,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,IAAK,OAAL,CACE,MAAO,IAAIH,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWmC,GAAX,CAAeN,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,IAAK,QAAL,CACE,MAAO,IAAIH,CAAAA,UAAJ,CAAe,QAAf,CAAyB+B,IAAI,CAAC5B,KAAL,CAAWoC,GAAX,CAAeP,KAAK,CAAC7B,KAArB,CAAzB,CAAP,CACF,QACE,KAAK2B,KAAL,CAAY,8BAA6BN,IAAI,CAACS,QAAS,GAAvD,CADF,CAbF,CAgBD,CAED,GAAkB,sBAAd,GAAAT,IAAI,CAACtB,IAAT,CAA0C,MAClC6B,CAAAA,IAAI,CAAG,KAAM,MAAKT,YAAL,CAAkBE,IAAI,CAACO,IAAvB,CADqB,CAElCC,KAAK,CAAG,KAAM,MAAKV,YAAL,CAAkBE,IAAI,CAACQ,KAAvB,CAFoB,IAIpCQ,CAAAA,SAAS,CAAGT,IAAI,CAAC5B,KAJmB,CAKpCsC,UAAU,CAAGT,KAAK,CAAC7B,KALiB,MAOlCuC,CAAAA,gBAAgB,CAAG,CAACX,IAAD,CAAOC,KAAP,GACvB;AACAlC,KAAK,CAACQ,SAAN,CAAgByB,IAAI,CAAC7B,IAArB,GACAJ,KAAK,CAACQ,SAAN,CAAgB0B,KAAK,CAAC9B,IAAtB,CAVsC,CAalCyC,cAAc,CAAG,CAACZ,IAAD,CAAOC,KAAP,GACrBlC,KAAK,CAACA,KAAN,CAAY8C,KAAZ,CAAkBC,MAAlB,CAAyBd,IAAI,CAAC7B,IAA9B,GACAJ,KAAK,CAACA,KAAN,CAAY8C,KAAZ,CAAkBC,MAAlB,CAAyBb,KAAK,CAAC9B,IAA/B,CAfsC,CA6BxC,OARIwC,gBAAgB,CAACX,IAAD,CAAOC,KAAP,CAAhB,EAAiCW,cAAc,CAACZ,IAAD,CAAOC,KAAP,CAQnD,EAPEQ,SAAS,CAAG5C,SAAS,CAACkD,IAAV,CAAeN,SAAf,CAOd,CANEC,UAAU,CAAG7C,SAAS,CAACkD,IAAV,CAAeL,UAAf,CAMf,GALW,CAAC3C,KAAK,CAACM,SAAN,CAAgB2B,IAAI,CAAC7B,IAArB,CAAD,EACT,CAACJ,KAAK,CAACM,SAAN,CAAgB4B,KAAK,CAAC9B,IAAtB,CAIH,GAHE,KAAK4B,KAAL,CAAY,sCAAqCN,IAAI,CAACS,QAAS,gDAA+CF,IAAI,CAAC7B,IAAK,UAAS8B,KAAK,CAAC9B,IAAK,GAA5I,CAGF,CAAQsB,IAAI,CAACS,QAAb,EACE,IAAK,SAAL,CACE,MAAO,IAAIjC,CAAAA,UAAJ,CAAe,MAAf,CAAuBwC,SAAS,CAACO,EAAV,CAAaN,UAAb,CAAvB,CAAP,CACF,IAAK,eAAL,CACE,MAAO,IAAIzC,CAAAA,UAAJ,CAAe,MAAf,CAAuBwC,SAAS,CAACQ,GAAV,CAAcP,UAAd,CAAvB,CAAP,CACF,IAAK,MAAL,CACE,MAAO,IAAIzC,CAAAA,UAAJ,CAAe,MAAf,CAAuBwC,SAAS,CAACS,EAAV,CAAaR,UAAb,CAAvB,CAAP,CACF,IAAK,YAAL,CACE,MAAO,IAAIzC,CAAAA,UAAJ,CAAe,MAAf,CAAuBwC,SAAS,CAACU,GAAV,CAAcT,UAAd,CAAvB,CAAP,CACF,IAAK,aAAL,CACE,MAAO,IAAIzC,CAAAA,UAAJ,CAAe,MAAf,CAAuBwC,SAAS,CAACW,EAAV,CAAaV,UAAb,CAAvB,CAAP,CACF,IAAK,YAAL,CACE,MAAO,IAAIzC,CAAAA,UAAJ,CAAe,MAAf,CAAuB,CAACwC,SAAS,CAACW,EAAV,CAAaV,UAAb,CAAxB,CAAP,CAZJ,CAcD,CAED,GAAkB,mBAAd,GAAAjB,IAAI,CAACtB,IAAT,OACM,CAAC,KAAM,MAAKoB,YAAL,CAAkBE,IAAI,CAAC4B,SAAvB,CAAP,EAA0CjD,KADhD,CAEW,KAAKmB,YAAL,CAAkBE,IAAI,CAACO,IAAvB,CAFX,CAKS,KAAKT,YAAL,CAAkBE,IAAI,CAACQ,KAAvB,CALT,CAQA,GAAkB,mBAAd,GAAAR,IAAI,CAACtB,IAAT,CAAuC,CACrC,KAAM6B,CAAAA,IAAI,CAAG,KAAM,MAAKT,YAAL,CAAkBE,IAAI,CAACO,IAAvB,CAAnB,CACA,GAAIsB,CAAAA,UAAJ,CAUA,MAPEA,CAAAA,UAOF,CARIvD,KAAK,CAACM,SAAN,CAAgB2B,IAAI,CAAC7B,IAArB,CAQJ,CAPe6B,IAAI,CAAC5B,KAAL,CAAWmD,MAAX,EAOf,CANyB,SAAd,GAAAvB,IAAI,CAAC7B,IAAL,EAA2B6B,IAAI,CAAC7B,IAAL,CAAUqD,UAAV,CAAqB,OAArB,CAMtC,CALe,WAAWC,IAAX,CAAgBzB,IAAI,CAAC5B,KAArB,CAKf,CAHe,CAAC4B,IAAI,CAAC5B,KAGrB,CAAOkD,UAAU,CAAG,KAAK/B,YAAL,CAAkBE,IAAI,CAACQ,KAAvB,CAAH,CAAmCD,IACrD,CAED,GAAkB,YAAd,GAAAP,IAAI,CAACtB,IAAT,CAAgC,CACzB,KAAKU,QAAL,CAAc6C,cAAd,CAA6BjC,IAAI,CAACrB,KAAlC,CADyB,EAE5B,KAAK2B,KAAL,CAAY,sBAAqBN,IAAI,CAACrB,KAAM,GAA5C,CAF4B,CAK9B,KAAMuD,CAAAA,OAAO,CAAG,KAAK9C,QAAL,CAAcY,IAAI,CAACrB,KAAnB,CAAhB,CACA,MAAO,IAAIH,CAAAA,UAAJ,CAAe0D,OAAO,CAACxD,IAAvB,CAA6BwD,OAAO,CAACvD,KAArC,CACR,CAED,GAAkB,gBAAd,GAAAqB,IAAI,CAACtB,IAAT,CAAoC,CAClC;AACA,GAAIyD,CAAAA,MAAJ,CAEA;AAEEA,MANgC,CAKT,YAArB,GAAAnC,IAAI,CAACmC,MAAL,CAAYzD,IAAZ,EAA2D,MAAtB,GAAAsB,IAAI,CAACmC,MAAL,CAAYxD,KALnB,CAMvB,KAAKW,EANkB,CAQvB,KAAM,MAAKQ,YAAL,CAAkBE,IAAI,CAACmC,MAAvB,CARiB,CAWd,SAAhB,GAAAA,MAAM,CAACzD,IAAP,EACc,SAAhB,GAAAyD,MAAM,CAACzD,IAZyB,CAahC,KAAK4B,KAAL,CAAW,8CAAX,CAbgC,CAcvB,CAAClC,SAAS,CAACgE,oBAAV,CAA+BD,MAAM,CAACxD,KAAtC,CAdsB,EAehC,KAAK2B,KAAL,CAAY,gCAA+B6B,MAAM,CAACxD,KAAM,GAAxD,CAfgC,MAkB5B0D,CAAAA,MAAM,CAAG,KAAM,MAAK5C,aAAL,CAAmBO,IAAI,CAACqC,MAAxB,CAlBa,CAmB5BC,OAAO,CAAGtC,IAAI,CAACsC,OAnBa,CAqB5BC,IAAI,CAAGtE,GAAG,CAACuE,kBAAJ,CAAuB,CAClCC,IAAI,CAAEzC,IAAI,CAAC0C,MADuB,CAElChE,IAAI,CAAE,UAF4B,CAIlC2D,MAJkC,CAKlCC,OALkC,CAAvB,CAMVD,MAAM,CAACxC,GAAP,CAAY8C,KAAD,EAAWA,KAAK,CAAChE,KAA5B,CANU,CArBqB,CA6B5BiE,UAAU,CAAGN,OAAO,CAAC,CAAD,CAAP,CAAW5D,IA7BI,CA8BlC,MAAO,MAAKa,GAAL,CAASgD,IAAT,CAAc,CACnBjD,EAAE,CAAE6C,MAAM,CAACxD,KADQ,CAEnBkE,IAAI,CAAEN,IAFa,CAAd,EAGJO,IAHI,CAIJD,IAAD,EAAU,GAAIrE,CAAAA,UAAJ,CAAeoE,UAAf,CAA2B3E,GAAG,CAAC8E,eAAJ,CAAoBH,UAApB,CAAgCC,IAAhC,CAA3B,CAJL,CAMR,CAED,GAAkB,gBAAd,GAAA7C,IAAI,CAACtB,IAAT,CAAoC,CAClC,KAAMsE,CAAAA,UAAU,CAAGhD,IAAI,CAACyC,IAAxB,CAEK,KAAKjD,OAAL,CAAayD,MAAb,CAAoBD,UAApB,CAH6B,EAIhC,KAAK1C,KAAL,CAAY,GAAE0C,UAAW,iCAAzB,CAJgC,MAO5BX,CAAAA,MAAM,CAAG,KAAM,MAAK5C,aAAL,CAAmBO,IAAI,CAACqC,MAAxB,CAPa,CAQ5Ba,MAAM,CAAG,KAAM,MAAK1D,OAAL,CAAa2D,OAAb,CAAqBH,UAArB,CAAiCX,MAAjC,CARa,CAUlC,MAAO,IAAI7D,CAAAA,UAAJ,CAAe0E,MAAM,CAACxE,IAAtB,CAA4BwE,MAAM,CAACvE,KAAnC,CACR,CACF,CAED;;;;KAKA,KAAMyE,CAAAA,QAAN,EAAkB,CAChB,MAAO,MAAK3D,aAAL,CACL,KAAKN,GAAL,CAASgB,IADJ,EAEL2C,IAFK,CAGJO,cAAD,EAAoBA,cAAc,CAACjD,IAAf,CAAoB,EAApB,CAHf,CAKR,CAED;;;;KAKAE,KAAK,CAAEgD,GAAF,CAAO,CACV,KAAM,IAAIvE,CAAAA,KAAJ,CAAW,UAASuE,GAAI,EAAxB,CACP,CArPa,CAwPhBC,MAAM,CAACC,OAAP,CAAiB,CACftE,SADe,CAGf;;;;;;;;;;KAWAkE,QAAQ,CAAEjE,GAAF,CAAOC,QAAP,CAAiBqE,OAAjB,CAA0B,CAChC,MAAO,IAAIvE,CAAAA,SAAJ,CAAcC,GAAd,CAAmBC,QAAnB,CAA6BqE,OAA7B,EAAsCL,QAAtC,EACR,CAhBc,C","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nconst ABI = require('web3-eth-abi')\nconst Eth = require('web3-eth')\nconst Web3Utils = require('web3-utils')\nconst BN = require('bn.js')\nconst types = require('../types')\nconst { Helpers } = require('../helpers')\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor (type, value) {\n    this.type = type\n    this.value = value\n\n    if (types.isInteger(this.type) && !BN.isBN(this.value)) {\n      this.value = new BN(this.value)\n    }\n\n    if (this.type === 'address') {\n      if (!Web3Utils.isAddress(this.value)) {\n        throw new Error(`Invalid address \"${this.value}\"`)\n      }\n      this.value = Web3Utils.toChecksumAddress(this.value)\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString () {\n    return this.value.toString()\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nclass Evaluator {\n  constructor (ast, bindings, { ethNode, to } = {}) {\n    this.ast = ast\n    this.bindings = bindings\n    this.eth = new Eth(ethNode || 'https://mainnet.infura.io')\n    this.to = to && new TypedValue('address', to)\n    this.helpers = new Helpers(this.eth)\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes (nodes) {\n    return Promise.all(\n      nodes.map(this.evaluateNode.bind(this))\n    )\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<string>}\n   */\n  async evaluateNode (node) {\n    if (node.type === 'ExpressionStatement') {\n      return (await this.evaluateNodes(node.body)).join(' ')\n    }\n\n    if (node.type === 'GroupedExpression') {\n      return this.evaluateNode(node.body)\n    }\n\n    if (node.type === 'MonologueStatement') {\n      return new TypedValue('string', node.value)\n    }\n\n    if (node.type === 'StringLiteral') {\n      return new TypedValue('string', node.value || '')\n    }\n\n    if (node.type === 'NumberLiteral') {\n      return new TypedValue('int256', node.value)\n    }\n\n    if (node.type === 'BytesLiteral') {\n      const length = Math.ceil((node.value.length - 2) / 2)\n      if (length > 32) {\n        this.panic('Byte literal represents more than 32 bytes')\n      }\n\n      return new TypedValue(`bytes${length}`, node.value)\n    }\n\n    if (node.type === 'BoolLiteral') {\n      return new TypedValue('bool', node.value === 'true')\n    }\n\n    if (node.type === 'BinaryExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      // String concatenation\n      if ((left.type === 'string' ||\n        right.type === 'string') &&\n        node.operator === 'PLUS') {\n        return new TypedValue('string', left.value.toString() + right.value.toString())\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) ||\n        !types.isInteger(right.type)) {\n        this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer types \"${left.type}\" and \"${right.type}\"`)\n      }\n\n      switch (node.operator) {\n        case 'PLUS':\n          return new TypedValue('int256', left.value.add(right.value))\n        case 'MINUS':\n          return new TypedValue('int256', left.value.sub(right.value))\n        case 'STAR':\n          return new TypedValue('int256', left.value.mul(right.value))\n        case 'POWER':\n          return new TypedValue('int256', left.value.pow(right.value))\n        case 'SLASH':\n          return new TypedValue('int256', left.value.div(right.value))\n        case 'MODULO':\n          return new TypedValue('int256', left.value.mod(right.value))\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`)\n      }\n    }\n\n    if (node.type === 'ComparisonExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      let leftValue = left.value\n      let rightValue = right.value\n\n      const bothTypesAddress = (left, right) => (\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) &&\n        types.isAddress(right.type)\n      )\n\n      const bothTypesBytes = (left, right) => (\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type)\n      )\n\n      // Conversion to BN for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = Web3Utils.toBN(leftValue)\n        rightValue = Web3Utils.toBN(rightValue)\n      } else if (!types.isInteger(left.type) ||\n        !types.isInteger(right.type)) {\n        this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${right.type}\"`)\n      }\n\n      switch (node.operator) {\n        case 'GREATER':\n          return new TypedValue('bool', leftValue.gt(rightValue))\n        case 'GREATER_EQUAL':\n          return new TypedValue('bool', leftValue.gte(rightValue))\n        case 'LESS':\n          return new TypedValue('bool', leftValue.lt(rightValue))\n        case 'LESS_EQUAL':\n          return new TypedValue('bool', leftValue.lte(rightValue))\n        case 'EQUAL_EQUAL':\n          return new TypedValue('bool', leftValue.eq(rightValue))\n        case 'BANG_EQUAL':\n          return new TypedValue('bool', !leftValue.eq(rightValue))\n      }\n    }\n\n    if (node.type === 'TernaryExpression') {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left)\n      }\n\n      return this.evaluateNode(node.right)\n    }\n\n    if (node.type === 'DefaultExpression') {\n      const left = await this.evaluateNode(node.left)\n      let leftFalsey\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero()\n      } else if (left.type === 'address' || left.type.startsWith('bytes')) {\n        leftFalsey = /^0x[0]*$/.test(left.value)\n      } else {\n        leftFalsey = !left.value\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left\n    }\n\n    if (node.type === 'Identifier') {\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`)\n      }\n\n      const binding = this.bindings[node.value]\n      return new TypedValue(binding.type, binding.value)\n    }\n\n    if (node.type === 'CallExpression') {\n      // TODO Add a check for number of return values (can only be 1 for now)\n      let target\n\n      // Inject self\n      if (node.target.type === 'Identifier' && node.target.value === 'self') {\n        target = this.to\n      } else {\n        target = await this.evaluateNode(node.target)\n      }\n\n      if (target.type !== 'bytes20' &&\n        target.type !== 'address') {\n        this.panic('Target of call expression was not an address')\n      } else if (!Web3Utils.checkAddressChecksum(target.value)) {\n        this.panic(`Checksum failed for address \"${target.value}\"`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const outputs = node.outputs\n\n      const call = ABI.encodeFunctionCall({\n        name: node.callee,\n        type: 'function',\n\n        inputs,\n        outputs\n      }, inputs.map((input) => input.value))\n\n      const returnType = outputs[0].type\n      return this.eth.call({\n        to: target.value,\n        data: call\n      }).then(\n        (data) => new TypedValue(returnType, ABI.decodeParameter(returnType, data))\n      )\n    }\n\n    if (node.type === 'HelperFunction') {\n      const helperName = node.name\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const result = await this.helpers.execute(helperName, inputs)\n\n      return new TypedValue(result.type, result.value)\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {string}\n   */\n  async evaluate () {\n    return this.evaluateNodes(\n      this.ast.body\n    ).then(\n      (evaluatedNodes) => evaluatedNodes.join('')\n    )\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic (msg) {\n    throw new Error(`Error: ${msg}`)\n  }\n}\n\nmodule.exports = {\n  Evaluator,\n\n  /**\n   * Evaluates an AST\n   *\n   * @memberof radspec/evaluator\n   * @param {radspec/parser/AST} ast The AST to evaluate\n   * @param {radspec/Bindings} bindings An object of bindings and their values\n   * @param {?Object} options An options object\n   * @param {?string} options.ethNode The URL to an Ethereum node\n   * @param {?string} options.to The destination address for this expression's transaction\n   * @return {string}\n   */\n  evaluate (ast, bindings, options) {\n    return new Evaluator(ast, bindings, options).evaluate()\n  }\n}\n"],"file":"index.js"}