"use strict";/**
 * @module radspec/evaluator
 */const ABI=require("web3-eth-abi"),Eth=require("web3-eth"),Web3Utils=require("web3-utils"),BN=require("bn.js"),types=require("../types"),_require=require("../helpers"),Helpers=_require.Helpers;/**
 * A value coupled with a type
 *
 * @class TypedValue
 * @param {string} type The type of the value
 * @param {*} value The value
 * @property {string} type
 * @property {*} value
 */class TypedValue{constructor(type,value){if(this.type=type,this.value=value,types.isInteger(this.type)&&!BN.isBN(this.value)&&(this.value=new BN(this.value)),"address"===this.type){if(!Web3Utils.isAddress(this.value))throw new Error(`Invalid address "${this.value}"`);this.value=Web3Utils.toChecksumAddress(this.value)}}/**
   * Get the string representation of the wrapped value
   *
   * @return {string}
   */toString(){return this.value.toString()}}/**
 * Walks an AST and evaluates each node.
 *
 * @class Evaluator
 * @param {radspec/parser/AST} ast The AST to evaluate
 * @param {radspec/Bindings} bindings An object of bindings and their values
 * @param {?Object} options An options object
 * @param {?string} options.ethNode The URL to an Ethereum node
 * @param {?string} options.to The destination address for this expression's transaction
 * @property {radspec/parser/AST} ast
 * @property {radspec/Bindings} bindings
 */class Evaluator{constructor(ast,bindings,{ethNode,to}={}){this.ast=ast,this.bindings=bindings,this.eth=new Eth(ethNode||"https://mainnet.infura.io"),this.to=to&&new TypedValue("address",to),this.helpers=new Helpers(this.eth)}/**
   * Evaluate an array of AST nodes.
   *
   * @param  {Array<radspec/parser/Node>} nodes
   * @return {Promise<Array<string>>}
   */async evaluateNodes(nodes){return Promise.all(nodes.map(this.evaluateNode.bind(this)))}/**
   * Evaluate a single node.
   *
   * @param  {radspec/parser/Node} node
   * @return {Promise<string>}
   */async evaluateNode(node){var _Mathceil=Math.ceil;if("ExpressionStatement"===node.type)return(await this.evaluateNodes(node.body)).join(" ");if("GroupedExpression"===node.type)return this.evaluateNode(node.body);if("MonologueStatement"===node.type)return new TypedValue("string",node.value);if("StringLiteral"===node.type)return new TypedValue("string",node.value||"");if("NumberLiteral"===node.type)return new TypedValue("int256",node.value);if("BytesLiteral"===node.type){const length=_Mathceil((node.value.length-2)/2);return 32<length&&this.panic("Byte literal represents more than 32 bytes"),new TypedValue(`bytes${length}`,node.value)}if("BoolLiteral"===node.type)return new TypedValue("bool","true"===node.value);if("BinaryExpression"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);// String concatenation
if(("string"===left.type||"string"===right.type)&&"PLUS"===node.operator)return new TypedValue("string",left.value.toString()+right.value.toString());// TODO Additionally check that the type is signed if subtracting
switch(types.isInteger(left.type)&&types.isInteger(right.type)||this.panic(`Cannot evaluate binary expression "${node.operator}" for non-integer types "${left.type}" and "${right.type}"`),node.operator){case"PLUS":return new TypedValue("int256",left.value.add(right.value));case"MINUS":return new TypedValue("int256",left.value.sub(right.value));case"STAR":return new TypedValue("int256",left.value.mul(right.value));case"POWER":return new TypedValue("int256",left.value.pow(right.value));case"SLASH":return new TypedValue("int256",left.value.div(right.value));case"MODULO":return new TypedValue("int256",left.value.mod(right.value));default:this.panic(`Undefined binary operator "${node.operator}"`);}}if("ComparisonExpression"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);let leftValue=left.value,rightValue=right.value;const bothTypesAddress=(left,right)=>// isAddress is true if type is address or bytes with size less than 20
types.isAddress(left.type)&&types.isAddress(right.type),bothTypesBytes=(left,right)=>types.types.bytes.isType(left.type)&&types.types.bytes.isType(right.type);switch(bothTypesAddress(left,right)||bothTypesBytes(left,right)?(leftValue=Web3Utils.toBN(leftValue),rightValue=Web3Utils.toBN(rightValue)):(!types.isInteger(left.type)||!types.isInteger(right.type))&&this.panic(`Cannot evaluate binary expression "${node.operator}" for non-integer or fixed-size bytes types "${left.type}" and "${right.type}"`),node.operator){case"GREATER":return new TypedValue("bool",leftValue.gt(rightValue));case"GREATER_EQUAL":return new TypedValue("bool",leftValue.gte(rightValue));case"LESS":return new TypedValue("bool",leftValue.lt(rightValue));case"LESS_EQUAL":return new TypedValue("bool",leftValue.lte(rightValue));case"EQUAL_EQUAL":return new TypedValue("bool",leftValue.eq(rightValue));case"BANG_EQUAL":return new TypedValue("bool",!leftValue.eq(rightValue));}}if("TernaryExpression"===node.type)return(await this.evaluateNode(node.predicate)).value?this.evaluateNode(node.left):this.evaluateNode(node.right);if("DefaultExpression"===node.type){const left=await this.evaluateNode(node.left);let leftFalsey;return leftFalsey=types.isInteger(left.type)?left.value.isZero():"address"===left.type||left.type.startsWith("bytes")?/^0x[0]*$/.test(left.value):!left.value,leftFalsey?this.evaluateNode(node.right):left}if("Identifier"===node.type){this.bindings.hasOwnProperty(node.value)||this.panic(`Undefined binding "${node.value}"`);const binding=this.bindings[node.value];return new TypedValue(binding.type,binding.value)}if("CallExpression"===node.type){// TODO Add a check for number of return values (can only be 1 for now)
let target;// Inject self
target="Identifier"===node.target.type&&"self"===node.target.value?this.to:await this.evaluateNode(node.target),"bytes20"!==target.type&&"address"!==target.type?this.panic("Target of call expression was not an address"):!Web3Utils.checkAddressChecksum(target.value)&&this.panic(`Checksum failed for address "${target.value}"`);const inputs=await this.evaluateNodes(node.inputs),outputs=node.outputs,call=ABI.encodeFunctionCall({name:node.callee,type:"function",inputs,outputs},inputs.map(input=>input.value)),returnType=outputs[0].type;return this.eth.call({to:target.value,data:call}).then(data=>new TypedValue(returnType,ABI.decodeParameter(returnType,data)))}if("HelperFunction"===node.type){const helperName=node.name;this.helpers.exists(helperName)||this.panic(`${helperName} helper function is not defined`);const inputs=await this.evaluateNodes(node.inputs),result=await this.helpers.execute(helperName,inputs);return new TypedValue(result.type,result.value)}}/**
   * Evaluate the entire AST.
   *
   * @return {string}
   */async evaluate(){return this.evaluateNodes(this.ast.body).then(evaluatedNodes=>evaluatedNodes.join(""))}/**
   * Report an error and abort evaluation.
   *
   * @param  {string} msg
   */panic(msg){throw new Error(`Error: ${msg}`)}}module.exports={Evaluator,/**
   * Evaluates an AST
   *
   * @memberof radspec/evaluator
   * @param {radspec/parser/AST} ast The AST to evaluate
   * @param {radspec/Bindings} bindings An object of bindings and their values
   * @param {?Object} options An options object
   * @param {?string} options.ethNode The URL to an Ethereum node
   * @param {?string} options.to The destination address for this expression's transaction
   * @return {string}
   */evaluate(ast,bindings,options){return new Evaluator(ast,bindings,options).evaluate()}};
//# sourceMappingURL=index.js.map