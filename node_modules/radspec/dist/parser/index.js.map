{"version":3,"sources":["../../src/parser/index.js"],"names":["PARSER_STATE","OK","ERROR","Parser","constructor","tokens","state","cursor","consume","previous","peek","matches","expected","eof","type","comparison","astBody","node","addition","operator","right","left","predicate","report","multiplication","power","unary","identifier","value","previousNode","length","pop","property","target","callee","inputs","functionInputs","outputs","push","helper","name","primary","NUMBER","STRING","HEXADECIMAL","BOOLEAN","expression","body","input","walk","token","parse","ast","console","error","module","exports"],"mappings":"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","sourcesContent":["/**\n * @module radspec/parser\n */\n\n/**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */\n\n/**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */\n/**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */\n\n/**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */\nconst PARSER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR'\n}\n\n/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */\nclass Parser {\n  constructor (tokens) {\n    this.state = PARSER_STATE.OK\n\n    this.tokens = tokens\n    this.cursor = 0\n  }\n\n  /**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */\n  consume () {\n    this.cursor++\n\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */\n  previous () {\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */\n  peek () {\n    return this.tokens[this.cursor]\n  }\n\n  /**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */\n  matches (...expected) {\n    if (this.eof()) return false\n    for (let type of expected) {\n      if (this.peek().type === type) {\n        this.cursor++\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  comparison (astBody) {\n    let node = this.addition(astBody)\n\n    while (this.matches('GREATER', 'GREATER_EQUAL', 'LESS', 'LESS_EQUAL', 'EQUAL_EQUAL', 'BANG_EQUAL')) {\n      let operator = this.previous().type\n      let right = this.addition(astBody)\n      node = {\n        type: 'ComparisonExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    if (this.matches('QUESTION_MARK')) {\n      node = {\n        type: 'TernaryExpression',\n        predicate: node,\n        left: this.comparison(astBody)\n      }\n\n      if (!this.matches('COLON')) {\n        this.report('Half-baked ternary (expected colon)')\n      }\n\n      node.right = this.comparison(astBody)\n    }\n\n    if (this.matches('DOUBLE_VERTICAL_BAR')) {\n      node = {\n        left: node,\n        right: this.comparison(),\n        type: 'DefaultExpression'\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  addition (astBody) {\n    let node = this.multiplication(astBody)\n\n    while (this.matches('MINUS', 'PLUS')) {\n      let operator = this.previous().type\n      let right = this.multiplication(astBody)\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  multiplication (astBody) {\n    let node = this.power(astBody)\n\n    while (this.matches('SLASH', 'STAR', 'MODULO')) {\n      let operator = this.previous().type\n      let right = this.power(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  power (astBody) {\n    let node = this.unary(astBody)\n\n    while (this.matches('POWER')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  unary (astBody) {\n    if (this.matches('BANG', 'MINUS')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      return {\n        type: 'UnaryExpression',\n        operator,\n        right: right\n      }\n    }\n\n    return this.identifier(astBody)\n  }\n\n  /**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  identifier (astBody) {\n    let node\n\n    if (this.matches('IDENTIFIER')) {\n      node = {\n        type: 'Identifier',\n        value: this.previous().value\n      }\n    }\n\n    if (!node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1]\n      if (previousNode && (\n        previousNode.type === 'Identifier' ||\n        previousNode.type === 'GroupedExpression' ||\n        previousNode.type === 'CallExpression'\n      )) {\n        node = previousNode\n        // Consume the last node as part of this node\n        astBody.pop()\n      }\n    }\n\n    if (node) {\n      while (this.matches('DOT')) {\n        let property = this.consume().value\n\n        node = {\n          type: 'PropertyAccessExpression',\n          target: node,\n          property\n        }\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node = {\n          type: 'CallExpression',\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: []\n        }\n\n        if (this.eof()) {\n          // TODO Better error\n          this.report('Unterminated call expression')\n        }\n\n        node.outputs.push({\n          type: this.type()\n        })\n      }\n\n      return node\n    }\n\n    return this.helper(astBody)\n  }\n\n  /**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  helper (astBody) {\n    if (this.matches('AT')) {\n      const identifier = this.consume()\n      const name = identifier.value\n\n      if (identifier.type !== 'IDENTIFIER') {\n        this.report(`Invalid helper function name '${name}' provided after @`)\n      }\n\n      const node = {\n        type: 'HelperFunction',\n        name: name\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node.inputs = this.functionInputs(astBody)\n      } else {\n        // There is actually no good reason not to allow calling a helper without ()\n        // this.report(`Expected '(' for executing helper function`)\n      }\n\n      return node\n    }\n\n    return this.primary(astBody)\n  }\n\n  /**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  primary (astBody) {\n    if (this.matches('NUMBER', 'STRING', 'HEXADECIMAL', 'BOOLEAN')) {\n      let type = {\n        NUMBER: 'NumberLiteral',\n        STRING: 'StringLiteral',\n        HEXADECIMAL: 'BytesLiteral',\n        BOOLEAN: 'BoolLiteral'\n      }[this.previous().type]\n\n      return {\n        type,\n        value: this.previous().value\n      }\n    }\n\n    if (this.matches('LEFT_PAREN')) {\n      let expression\n\n      do {\n        // Keep munching expressions in the context of the current expression\n        expression = this.comparison(expression ? [expression] : [])\n      } while (!this.eof() && !this.matches('RIGHT_PAREN'))\n\n      if (this.eof()) {\n        this.report('Unterminated grouping')\n      }\n\n      return {\n        type: 'GroupedExpression',\n        body: expression\n      }\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`)\n  }\n\n  /**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */\n  type () {\n    if (!this.matches('COLON') &&\n      this.peek().type !== 'TYPE') {\n      // TODO Better error\n      this.report(`Expected a type, got \"${this.peek().type}\"`)\n    }\n\n    return this.consume().value\n  }\n\n  /**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */\n  functionInputs (astBody) {\n    const inputs = []\n\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      const input = this.comparison(astBody)\n      if (!input.type) {\n        input.type = this.type()\n      } else if (this.matches('COLON')) {\n        this.report(`Unexpected type (already inferred type of parameter)`)\n      }\n\n      inputs.push(input)\n\n      // Break if the next character is not a comma or a right parenthesis\n      // If this is true, then we are specifying more parameters without\n      // delimiting them using comma.\n      if (!this.matches('COMMA') &&\n        this.peek().type !== 'RIGHT_PAREN') break\n    }\n\n    return inputs\n  }\n\n  /**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  walk (astBody) {\n    let token = this.peek()\n\n    if (token.type === 'MONOLOGUE') {\n      return {\n        type: 'MonologueStatement',\n        value: this.consume().value\n      }\n    }\n\n    if (token.type === 'TICK') {\n      let node = {\n        type: 'ExpressionStatement',\n        body: []\n      }\n\n      this.matches('TICK')\n\n      while (!this.eof() && this.peek().type !== 'TICK') {\n        node.body.push(this.walk(node.body))\n      }\n\n      if (this.eof()) {\n        this.report('Unterminated expression')\n      }\n\n      this.matches('TICK')\n\n      return node\n    }\n\n    return this.comparison(astBody)\n  }\n\n  /**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */\n  async parse () {\n    let ast = {\n      type: 'Program',\n      body: []\n    }\n\n    while (!this.eof()) {\n      ast.body.push(this.walk(ast.body))\n    }\n\n    if (this.state === PARSER_STATE.ERROR) {\n      console.error(`Errors encountered while parsing source`)\n      return ast\n    }\n\n    return ast\n  }\n\n  /**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof () {\n    return this.cursor >= this.tokens.length\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report (error) {\n    this.state = PARSER_STATE.ERROR\n    console.error(\n      `Error (${this.cursor}): ${error}`\n    )\n  }\n}\n\nmodule.exports = {\n  Parser,\n\n  /**\n   * Walks token list and returns an AST.\n   *\n   * @memberof radspec/parser\n   * @param  {Array<Token>} tokens\n   * @return {AST} The AST\n   */\n  parse (tokens) {\n    return new Parser(tokens).parse()\n  }\n}\n"],"file":"index.js"}