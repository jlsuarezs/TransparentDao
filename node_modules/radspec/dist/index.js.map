{"version":3,"sources":["../src/index.js"],"names":["ABI","require","scanner","parser","evaluator","evaluateRaw","source","bindings","evaluatorOptions","scan","then","parse","ast","evaluate","call","options","methodId","transaction","data","substr","method","abi","find","type","encodeFunctionSignature","parameterValues","decodeParameters","inputs","parameters","reduce","input","Object","assign","name","value","to","module","exports"],"mappings":"sLAAA;;;;IAKA;;IAIA;;QAGMA,CAAAA,GAAG,CAAGC,OAAO,CAAC,cAAD,C,CACbC,OAAO,CAAGD,OAAO,CAAC,WAAD,C,CACjBE,MAAM,CAAGF,OAAO,CAAC,UAAD,C,CAChBG,SAAS,CAAGH,OAAO,CAAC,aAAD,C,CAEzB;;;;;;;;;;;;;GAcA,QAASI,CAAAA,WAAT,CAAsBC,MAAtB,CAA8BC,QAA9B,CAAwCC,gBAAxC,CAA0D,CACxD,MAAON,CAAAA,OAAO,CAACO,IAAR,CAAaH,MAAb,EACJI,IADI,CACCP,MAAM,CAACQ,KADR,EAEJD,IAFI,CAEEE,GAAD,EAASR,SAAS,CAACS,QAAV,CAAmBD,GAAnB,CAAwBL,QAAxB,CAAkCC,gBAAlC,CAFV,CAGR,CAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuCA,QAASK,CAAAA,QAAT,CAAmBP,MAAnB,CAA2BQ,IAA3B,CAAiCC,OAAO,CAAG,EAA3C,CAA+C,CAC7C;AAD6C,KAEvCC,CAAAA,QAAQ,CAAGF,IAAI,CAACG,WAAL,CAAiBC,IAAjB,CAAsBC,MAAtB,CAA6B,CAA7B,CAAgC,EAAhC,CAF4B,CAKvCC,MAAM,CAAGN,IAAI,CAACO,GAAL,CAASC,IAAT,CAAeD,GAAD,EACd,UAAb,GAAAA,GAAG,CAACE,IAAJ,EACAP,QAAQ,GAAKhB,GAAG,CAACwB,uBAAJ,CAA4BH,GAA5B,CAFA,CAL8B,CAUvCI,eAAe,CAAGzB,GAAG,CAAC0B,gBAAJ,CACtBN,MAAM,CAACO,MADe,CAEtB,KAAOb,IAAI,CAACG,WAAL,CAAiBC,IAAjB,CAAsBC,MAAtB,CAA6B,EAA7B,CAFe,CAVqB,CAcvCS,UAAU,CAAGR,MAAM,CAACO,MAAP,CAAcE,MAAd,CAAqB,CAACD,UAAD,CAAaE,KAAb,GACtCC,MAAM,CAACC,MAAP,CACEJ,UADF,CACc,CACV,CAACE,KAAK,CAACG,IAAP,EAAc,CACZV,IAAI,CAAEO,KAAK,CAACP,IADA,CAEZW,KAAK,CAAET,eAAe,CAACK,KAAK,CAACG,IAAP,CAFV,CADJ,CADd,CADiB,CAQd,EARc,CAd0B,CAI7C;AAoBA;AACA;AACA,MAAO5B,CAAAA,WAAW,CAACC,MAAD,CAASsB,UAAT,+BAA0Bb,OAA1B,EAAmCoB,EAAE,CAAErB,IAAI,CAACG,WAAL,CAAiBkB,EAAxD,GACnB,CAEDC,MAAM,CAACC,OAAP,CAAiB,CACf5B,IAAI,CAAEP,OAAO,CAACO,IADC,CAEfE,KAAK,CAAER,MAAM,CAACQ,KAFC,CAIfN,WAJe,CAKfQ,QALe,C","sourcesContent":["/**\n * @typedef {Object} Binding\n * @property {string} type The type of the binding (a valid Radspec type)\n * @property {*} value The value of the binding\n */\n/**\n * @typedef {Object.<string, Binding>} Bindings\n */\n\n/**\n * @module radspec\n */\nconst ABI = require('web3-eth-abi')\nconst scanner = require('./scanner')\nconst parser = require('./parser')\nconst evaluator = require('./evaluator')\n\n/**\n * Evaluate a radspec expression with manual bindings.\n *\n * @example\n * const radspec = require('radspec')\n *\n * radspec.evaluateRaw('a is `a`', {\n *   a: { type: 'int256', value: 10 }\n * }).then(console.log)\n * @param  {string} source The radspec expression\n * @param  {Bindings} bindings An object of bindings and their values\n * @param {?Object} evaluatorOptions An options object for the evaluator\n * @return {Promise<string>} The result of the evaluation\n */\nfunction evaluateRaw (source, bindings, evaluatorOptions) {\n  return scanner.scan(source)\n    .then(parser.parse)\n    .then((ast) => evaluator.evaluate(ast, bindings, evaluatorOptions))\n}\n\n/**\n * Evaluate a radspec expression (`source`) for a transaction (`call`)\n *\n * @example\n * const radspec = require('radspec')\n *\n * const expression = 'Will multiply `a` by 7 and return `a * 7`.'\n * const call = {\n *   abi: [{\n *     name: 'multiply',\n *     constant: false,\n *     type: 'function',\n *     inputs: [{\n *       name: 'a',\n *       type: 'uint256'\n *     }],\n *     outputs: [{\n *       name: 'd',\n *       type: 'uint256'\n *     }]\n *   }],\n *   transaction: {\n *     to: '0x8521742d3f456bd237e312d6e30724960f72517a',\n *     data: '0xc6888fa1000000000000000000000000000000000000000000000000000000000000007a'\n *   }\n * }\n *\n * radspec.evaluate(expression, call)\n *   .then(console.log) // => \"Will multiply 122 by 7 and return 854.\"\n * @param {string} source The radspec expression\n * @param {Object} call The call that determines the bindings for this evaluation\n * @param {Array} call.abi The ABI used to decode the transaction data\n * @param {Object} call.transaction The transaction to decode for this evaluation\n * @param {string} call.transaction.to The destination address for this transaction\n * @param {string} call.transaction.data The transaction data\n * @param {?Object} options An options object\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @return {Promise<string>} The result of the evaluation\n */\nfunction evaluate (source, call, options = {}) {\n  // Get method ID\n  const methodId = call.transaction.data.substr(0, 10)\n\n  // Find method ABI\n  const method = call.abi.find((abi) =>\n    abi.type === 'function' &&\n    methodId === ABI.encodeFunctionSignature(abi))\n\n  // Decode parameters\n  const parameterValues = ABI.decodeParameters(\n    method.inputs,\n    '0x' + call.transaction.data.substr(10)\n  )\n  const parameters = method.inputs.reduce((parameters, input) =>\n    Object.assign(\n      parameters, {\n        [input.name]: {\n          type: input.type,\n          value: parameterValues[input.name]\n        }\n      }\n    ), {})\n\n  // Evaluate expression with bindings from\n  // the transaction data\n  return evaluateRaw(source, parameters, { ...options, to: call.transaction.to })\n}\n\nmodule.exports = {\n  scan: scanner.scan,\n  parse: parser.parse,\n\n  evaluateRaw,\n  evaluate\n}\n"],"file":"index.js"}